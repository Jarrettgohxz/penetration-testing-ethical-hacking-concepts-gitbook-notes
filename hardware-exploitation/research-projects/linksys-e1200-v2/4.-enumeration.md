# 4. Enumeration

### 4.1 Gaining a shell

<div data-full-width="true"><figure><img src="../../../.gitbook/assets/IMG_1.png" alt=""><figcaption></figcaption></figure></div>

<figure><img src="../../../.gitbook/assets/IMG_2.png" alt=""><figcaption></figcaption></figure>

{% embed url="https://jarrettgxz-sec.gitbook.io/penetration-testing-ethical-hacking-concepts/hardware-exploitation/techniques/uart-shell" %}

First, identify the device name of the USB-UART adapter:

```shellscript
$ ls /dev | grep -i usb
ttyUSB0
```

&#x20;Next, use `picocom` to retrieve a shell, with the baud rate as **115200** (a common first guess)

```shellscript
$ picocom -b 115200 /dev/ttyUSB0
```

* Received a log output with non-gibberish text
  * this means that the correct baud rate was chosen
* A "Hit enter to continue..." message was shown
  * From there, we are able to pop a **BusyBox v1.7.2 shell**

<figure><img src="../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### 4.2 General enumeration

List of enumeration steps:

1. Read through the initial boot logs
2. Identify firmware version (to verify if the current version is still vulnerable)

* `nvram`&#x20;
* build date

3. Identify architecture
4. Identify `httpd` binary locations
5. ...



#### 4.2.1 Boot logs

1. Boot version

```shellscript
CFE version 5.100.138.11 based on BBP 1.0.37 for BCM947XX (32bit,SP,LE)
Build Date: 11/23/11 12:16:38 CST (wzh@cybertan)
Copyright (C) 2000-2008 Broadcom Corporation.
```

2. Other useful information

```shellscript
Linux version 2.6.22 (wzh@cybertan) (gcc version 4.2.3) #2 Wed Feb 15 20:33:15 CST 2012
Kernel command line: root=/dev/mtdblock2 console=ttyS0,115200 init=/sbin/preinit
```

#### 4.2.2 Further enumeration

**Available memory**:

```console
# cat /proc/meminfo
# free
```

**List all the available binaries**:

```console
# echo $PATH
/usr/bin:/bin:/usr/sbin:/sbin

# ls /usr/bin
# ls /bin
# ls /usr/sbin
# ls /sbin
```

**Architecture & stack protections**:

```console
# uname -u
# cat /etc/version
# cat /etc/banner
# cat /etc/issue

# cat /proc/cpuinfo
# cat /proc/sys/kernel/randomize_va_space
```

### 4.3 Firmware version discovery

```shellscript
# firmware version
$ nvram get firmware_version
$ nvram show | grep -i version

# uname
$ uname -v
Wed Feb 15 20:33:15 CST 2012
```

* We have identified that the build date is **Feb 15 2012**

With the following simple Google dork:

```
site:downloads.linksys.com "e1200"
```

I managed to find details for a few release notes, with the earliest on **Aug 28, 2013**, and the latest on **Jan 5, 2018**

1. [https://downloads.linksys.com/downloads/866/465/E1200\_v2\_v2.2\_FwReleaseNotes,0.txt](https://downloads.linksys.com/downloads/866/465/E1200_v2_v2.2_FwReleaseNotes,0.txt)
2. [https://downloads.linksys.com/downloads/releasenotes/E1200\_v2\_v2.2\_FwReleaseNotes.txt](https://downloads.linksys.com/downloads/releasenotes/E1200_v2_v2.2_FwReleaseNotes.txt)

It is highly probable that the current firmware on the device has not been patched at all, and would most likely still be vulnerable to the CVEs we have discussed before.

#### 4.3.1 Web interface

We are able to identify the firmware version from the main web page running on port 80:

<figure><img src="../../../.gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>

* My device is running the firmware version **2.0.02**

### 4.4 `/tmp/httpd` binary (CVE)

Let's focus on the following CVE:

{% embed url="https://nvd.nist.gov/vuln/detail/CVE-2025-60690" %}

We will attempt to understand the entry point of the vulnerability. In this case, it would be the URL path we need to send our HTTP request (either _GET_, _POST_, etc.) in order to reach the `get_merge_ipaddr` function of the `httpd` binary

...

> The function concatenates up to four user-supplied CGI parameters

We know that the vulnerability deals with CGI

{% embed url="https://httpd.apache.org/docs/current/howto/cgi.html" %}

#### 4.3.1 Find all `.cgi` files

Look for all occurrences of the string value `.cgi` and extract the filenames. Next, we can look for the location, and view the content of these files:

```console
# find / -name 'xxxx.cgi' 2>/dev/null
...
# cat xxxx.cgi
```

#### 4.3.2 Finding information for the `get_merge_ipaddr` function

```console
# ls /www 
# ls -R /www/cgi-bin

# grep -r 'get_merge_ipaddr' /
```

