# 6. Reverse engineering (exploit development)

Given the information we have gathered from the previous section, we can attempt to perform reverse engineering to replicate the steps taken to discover the CVE, and potentially escalate it to RCE.

> Note that the terms "router", "device" and "target" will be used interchangeably

### 6.1 Transfer binary from host to device

Before we continue, let's install the busybox binary on the device (via UART), which provides us with a more comprehensive set of tools

{% embed url="https://www.busybox.net/" %}

**Host**:

```shellscript
$ wget https://busybox.net/downloads/binaries/1.21.1/busybox-mipsel

# host "busybox-mipsel" binary with a python3 server
$ python3 -m http.server <port>
```

**Device (UART console)**:

{% code title="UART console" %}
```console
# wget http://<HOST_IP>:<port>/busybox-mipsel -O /tmp/busybox-mipsel

#! use the newly retrieved "busybox-mipsel" binary
# /tmp/busybox-mipsel --help
```
{% endcode %}

### 6.2 Transfer binary from device to host

#### 6.2.1 tftp

**Host**:

* Enable **tftp** server

```shellscript
$ sudo apt install tftpd-hpa
$ sudo systemctl start tftpd-hpa
```

**Device (UART console)**:

```console
# tftp <HOST_IP>
# tftp> put /tmp/gn-httpd
```

#### 6.2.2 Netcat (busybox)

**Device (UART console)**:

{% code title="UART console" %}
```console
# /tmp/busybox-mipsel nc <router_ip> <port> < /tmp/gn-httpd
```
{% endcode %}

**Host**:

```shellscript
$ nc -lvp <port> > /path/to/gn-httpd
```

* We can now access the vulnerable binary from `/path/to/gn-httpd` on the host machine

### 6.3 Ghidra

...

### 6.4 `gdb`, `gdbserver`&#x20;

{% embed url="https://docs.hex-rays.com/user-guide/debugger/remote-debugging/remote-gdb-debugger/debugging-with-gdbserver" %}

{% embed url="https://gcc.gnu.org/onlinedocs/gcc-4.8.5/gnat_ugn_unw/Remote-Debugging-using-gdbserver.html" %}

#### 6.4.1 Compile `gdbserver` for the target's architecture

{% embed url="https://github.com/guyush1/gdb-static" %}

To start off, we have to retrieve the `gdbserver` binary for our target architecture **mipsel** (_mips little-endian_):

```shellscript
$ wget https://github.com/guyush1/gdb-static/releases/download/v17.1-static/gdb-static-full-mipsel.tar.gz
```

Next, we transfer the entire `gdb-static-full-mipsel.tar.gz` file to the target device, and run the following commands to get access to a range of useful binary for reversing:

```console
# /tmp/busybox-mipsel tar -xvzf gdb-static-full-mipsel.tar.gz
# ls
addr2line gdb        objdump    strings
ar        gdbserver  objcopy    ...
as        ld          readelf    ...
```

#### 6.4.2 `gdbserver` on target router

Next, we can run `gdbserver` on the target router:

> We can use the steps outlined in the previous steps to transfer the `gdbserver` binary from host to the device

{% code title="UART console" %}
```console
# gdbserver localhost:<port> <program>

#! eg. 
# gdbserver localhost:8888 /path/to/httpd
```
{% endcode %}

Alternatively, launch from PID of a running program:

{% code title="UART console" %}
```console
# gdbserver localhost:<port> --attach <PID_of_program>

#! eg.
# pidof httpd
# gdbserver localhost:8888 --attach <PID>
```
{% endcode %}

#### 6.4.3 Connect to remote target from host machine

* To debug (using `gdb`) from the host machine
  * Since we know that our router uses the `mipsel` architecture (simply `mips` with _little-endian_), we have to set it up appropriately

```shellscript
$ gdb
gdb> set architecture mips
gdb> set endian little
gdb> target remote <host>:<port>

# eg.
gdb> target remote 8.8.8.8:8888
```

### 6.5 xxxx

...
