# 6. Reverse engineering (exploit development)

Given the information we have gathered from the previous section, we can attempt to perform reverse engineering to replicate the steps taken to discover the CVE, and potentially escalate it to RCE.

> Note that the terms "router", "device" and "target" will be used interchangeably

### 6.1 Reclaim memory space

We can attempt to reclaim memory space on the router by killing some of the unneccessary processes:

{% code title="UART console" %}
```console
# ps
...
264 root       3332 S   resetbutton
329 root       2440 S   tftpd -s /tmp -c -l -P E150
330 root       2168 S   cron
333 root       3864 S   httpd
336 root       3864 S   /tmp/gn-httpd -p 51000 -G
340 root       2272 S   dnsmasq -R -h -i br1 -i br0 -c 0 -r /tmp/resolv.conf
345 root       1024 S   cesmDNS -o /tmp/.mdns_host_info -d -h CISCO007 -l 192
347 root       6936 S   /tmp/gn-dhcpd -cf /tmp/dhcpd-br1.conf -lf /tmp/dhcpd-
349 root       6936 S   dhcpd -cf /tmp/dhcpd-br0.conf -lf /tmp/dhcpd.leases -
354 root       3164 S   upnp -D -W vlan2
385 root       2180 S   /bin/eapd
388 root       2576 S   nas
392 root       3764 S   /bin/wps_monitor
394 root       2156 S   netbios /tmp/samba/lib/netbios.conf
419 root       1436 S   /usr/sbin/lld2d br0
473 root       2804 S   /sbin/monitor_cable
536 root       1772 S   /bin/sh

#  
```
{% endcode %}



### 6.2 Transfer binary from host to device

> Remember to always check the available memory space available on the device, before transferring files

Before we continue, let's install the busybox binary on the device (via UART), which provides us with a more comprehensive set of tools

{% embed url="https://www.busybox.net/" %}

**Host**:

```shellscript
$ wget https://busybox.net/downloads/binaries/1.21.1/busybox-mipsel

# host "busybox-mipsel" binary with a python3 server
$ python3 -m http.server <port>
```

**Device (UART console)**:

{% code title="UART console" %}
```console
# wget http://<HOST_IP>:<port>/busybox-mipsel -O /tmp/busybox-mipsel

#! use the newly retrieved "busybox-mipsel" binary
# /tmp/busybox-mipsel --help
```
{% endcode %}

### 6.3 Transfer binary from device to host

#### 6.3.1 tftp

**Host**:

* Enable **tftp** server

```shellscript
$ sudo apt install tftpd-hpa
$ sudo systemctl start tftpd-hpa
```

**Device (UART console)**:

```console
# tftp <HOST_IP>
# tftp> put /tmp/gn-httpd
```

#### 6.3.2 Netcat (busybox)

**Device (UART console)**:

{% code title="UART console" %}
```console
# /tmp/busybox-mipsel nc <router_ip> <port> < /tmp/gn-httpd
```
{% endcode %}

**Host**:

```shellscript
$ nc -lvp <port> > /path/to/gn-httpd
```

* We can now access the vulnerable binary from `/path/to/gn-httpd` on the host machine

### 6.4 Ghidra

...

### 6.5 `gdb`, `gdbserver`&#x20;

{% embed url="https://docs.hex-rays.com/user-guide/debugger/remote-debugging/remote-gdb-debugger/debugging-with-gdbserver" %}

{% embed url="https://gcc.gnu.org/onlinedocs/gcc-4.8.5/gnat_ugn_unw/Remote-Debugging-using-gdbserver.html" %}

#### 6.5.1 Compile `gdbserver` for the target's architecture

{% embed url="https://github.com/guyush1/gdb-static" %}

To start off, we have to retrieve the `gdbserver` binary for our target architecture **mipsel** (_mips little-endian_):

{% code overflow="wrap" %}
```shellscript
$ wget https://github.com/guyush1/gdb-static/releases/download/v17.1-static/gdb-static-full-mipsel.tar.gz

$ tar -xzvf gdb-static-full-mipsel.tar.gz
$ ls 
addr2line gdb        objdump    strings
ar        gdbserver  objcopy    ...
as        ld          readelf    ...
```
{% endcode %}

Due to limited space on the device, we can only store a few selected binaries at once. In this case, this will be `gdbserver`.

> Remember to always check the available memory space available on the device, before transferring files

#### 6.5.2 `gdbserver` on target router

Next, we can run `gdbserver` on the target router:

> We can use the steps outlined in the previous steps to transfer the `gdbserver` binary from host to the device

{% code title="UART console" %}
```console
# gdbserver localhost:<port> <program>

#! eg. 
# gdbserver localhost:8888 /path/to/httpd
```
{% endcode %}

Alternatively, launch from PID of a running program:

{% code title="UART console" %}
```console
# gdbserver localhost:<port> --attach <PID_of_program>

#! eg.
# pidof httpd
# gdbserver localhost:8888 --attach <PID>
```
{% endcode %}

#### 6.5.3 Connect to remote target from host machine

* To debug (using `gdb`) from the host machine
  * Since we know that our router uses the `mipsel` architecture (simply `mips` with _little-endian_), we have to set it up appropriately

```shellscript
$ gdb
gdb> set architecture mips
gdb> set endian little
gdb> target remote <host>:<port>

# eg.
gdb> target remote 8.8.8.8:8888
```

### 6.6 xxxx

...
