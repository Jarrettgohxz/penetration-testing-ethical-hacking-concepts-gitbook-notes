# Exploit research

### 6.4 Initial findings

#### checksec

```shellscript
$ pwn checksec gn-httpd
[*] '/home/user/linksys-e1200-v2/gn-httpd'
    Arch:     mips-32-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x400000)
    RWX:      Has RWX segments
```

We can see that the `gn-httpd` binary does not have any form of protection

#### objdump

> Note that the objdump binary used is from the `binutils-mipsel-linux-gnu` library

```shellscript
$ sudo apt install binutils-mipsel-linux-gnu
$ ls /usr/mipsel-linux-gnu/bin
ar  as  gold  ld  ld.bfd  ld.gold  nm  objcopy  objdump  ranlib  readelf  strip

$ /usr/mipsel-linux-gnu/bin/objdump -d --disassemble=get_merge_ipaddr gn-httpd
```

### 6.5 Ghidra

#### `get_merge_ipaddr`

<figure><img src="../../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

```c
undefined4 get_merge_ipaddr(undefined4 param_1,char *param_2)

{
  char *__src;
  size_t sVar1;
  int iVar2;
  char acStack_48 [32];
  
  *param_2 = '\0';
  iVar2 = 0;
  while( true ) {
    snprintf(acStack_48,0x1e,"%s_%d",param_1,iVar2);
    __src = (char *)get_cgi((ACTION)acStack_48);
    if (__src == (char *)0x0) {
      __src = "0";
    }
    strcat(param_2,__src);
    if (iVar2 == 3) break;
    iVar2 = iVar2 + 1;
    sVar1 = strlen(param_2);
    param_2[sVar1] = '.';
    (param_2 + sVar1)[1] = '\0';
    if (iVar2 == 4) {
      return 1;
    }
  }
  return 1;
}

```

#### Refined `get_merge_ipaddr`

```c
undefined4 get_merge_ipaddr(undefined4 a1, char *a2)

{
  char *__src;
  size_t sVar1;
  int iVar2;
  char acStack_48 [32];
  
  *a2 = '\0';
  // iVar2 = 0;
  
  // while(true) {
  for (int i=0; i<4; ++i) {
    snprintf(acStack_48,0x1e,"%s_%d",a1,i); //snprintf(acStack_48,0x1e,"%s_%d",param_1,iVar2);
    __src = (char *)get_cgi((ACTION)acStack_48);
    if (__src == (char *)0x0) {
      __src = "0";
    }
    strcat(a2,__src);
    
    //if (iVar2 == 3) break;
    if (i == 3) break;
    //iVar2 = iVar2 + 1;
    
    sVar1 = strlen(a2);
    a2[sVar1] = '.';
    (a2 + sVar1)[1] = '\0';

    //if (iVar2 == 4) {
    //  return 1;
    //}
  }
  return 1;
}
```

...

#### Analysis&#x20;

> Keep in mind that we are working with the MIPS assembly for this binary. The insrtuctions and concepts are different from common x86, x64 or ARM assembly

We can see that the `param_1` and `param_2` variables corresponds to the 1st and 2nd arguments passed to the `get_merge_ipaddr` function. As what we can understand from MIPS assembly, this relates to the `a0` and `a1` registers in the current function (`get_merge_ipaddr`)

However, this does not necessarily mean the same for the nested function calls within the current `get_merge_ipaddr` function (eg. `strcat`, `get_cgi`)

Hence, there may be a situation where the disassembly listing view shows a particular `param_x` variable (corresponding to `ax` register) passed in as an argument to a nested function call, but that does not actually correspond to the **x-positioned** argument to that function call

**Example 1**

Lets take the following disassembly + decompiled code snippet:

{% code title="disassembly" %}
```mips
 0041f994 21 20 20 02     _move      param_1,s1
                             LAB_0041f998                                    XREF[1]:     0041fa1c(j)  
 0041f998 09 f8 20 03     jalr       t9=><EXTERNAL>::strcat                           char * strcat(char * __dest, cha
 0041f99c 21 28 40 00     _move      param_2=>DAT_0049ea84,v0                         = 0030h

```
{% endcode %}

{% code title="decompiled code" %}
```c
strcat(param_2,__src);
```
{% endcode %}

From the instruction:

```mipsasm
0041f99c 21 28 40 00     _move      param_2=>DAT_0049ea84,v0                         = 0030h
```

We can see that the value in register `v0` is moved to the variable `param_2`, and this variable is then passed as the 1st argument to the `strcat` function (as seen from the decompiled code)

We might think that the value in register `v0` is used as the 1st argument to the `strcat` function. However, in reality, this register is actually moved to the `a1` register instead, which relates to the 2nd argument passed to the `strcat` function



**Other findings**

We can discover that the 2nd argument to the `get_merge_ipaddr` function is passed in as the 1st argument to the nested `strcat` function. Take a look at the following disassembly code (`objdump`):

```mipsasm
41f934:       00a08821        move    s1,a1 #1
...
41f994:       02202021        move    a0,s1 #2
41f998:       0320f809        jalr    t9 #3
```

1. _**(#1)**_ Move `a1` to `s1`&#x20;

* Moves the value of the 2nd argument to the `get_merge_ipaddr` function to the `s1` register

2. _**(#2)**_ Move `s1` to `a0`&#x20;

* `a0` (value from `s1`) indicates the 1st argument to the following function call (`strcat`)

3. _**(#3)**_ Calls the `strcat` function (address stored in temporary register `t9`)



**Important notes from each section**

1. Disassembly

* The `a0` to `an` registers indicates the exact values passed to each of the nested function calls

2. Decompiled code

* The `param_1` and `param_2` variables indicates the 1st and 2nd argument to the `get_merge_ipaddr` functions
* However, even though the 2nd argument (`param_2`) to the `get_merge_ipaddr` function is shown to be passed as the 1st argument to the `strcat` function, this is not actually the case
  * `param_2` refers to `a1`, which instead relates to the 2nd argument passed to the nested `strcat` function call instead



Hence, the _source of truth_ of argument passing should come from the `a0`, `a1`, `an`, etc. registers in the disassembly, rather than the decompiled code

### 6.6 `gdb`, `gdbserver`&#x20;

{% embed url="https://docs.hex-rays.com/user-guide/debugger/remote-debugging/remote-gdb-debugger/debugging-with-gdbserver" %}

{% embed url="https://gcc.gnu.org/onlinedocs/gcc-4.8.5/gnat_ugn_unw/Remote-Debugging-using-gdbserver.html" %}

#### 6.6.1 Compile `gdbserver` for the target's architecture

{% embed url="https://github.com/guyush1/gdb-static" %}

To start off, we have to retrieve the `gdbserver` binary for our target architecture **mipsel** (_mips little-endian_):

{% code overflow="wrap" %}
```shellscript
$ wget https://github.com/guyush1/gdb-static/releases/download/v17.1-static/gdb-static-full-mipsel.tar.gz

$ tar -xzvf gdb-static-full-mipsel.tar.gz
$ ls 
addr2line gdb        objdump    strings
ar        gdbserver  objcopy    ...
as        ld          readelf    ...
```
{% endcode %}

Due to limited space on the device, we can only store a few selected binaries at once. In this case, this will be `gdbserver`.

> Remember to always check the available memory space available on the device, before transferring files

#### 6.6.2 `gdbserver` on target router

Next, we can run `gdbserver` on the target router:

> We can use the steps outlined in the previous steps to transfer the `gdbserver` binary from host to the device

{% code title="UART console" %}
```console
# gdbserver localhost:<port> <program>

#! eg. 
# gdbserver localhost:8888 /path/to/httpd
```
{% endcode %}

Alternatively, launch from PID of a running program:

{% code title="UART console" %}
```console
# gdbserver localhost:<port> --attach <PID_of_program>

#! eg.
# pidof httpd
# gdbserver localhost:8888 --attach <PID>
```
{% endcode %}

#### 6.6.3 Connect to remote target from host machine

* To debug (using `gdb`) from the host machine
  * Since we know that our router uses the `mipsel` architecture (simply `mips` with _little-endian_), we have to set it up appropriately

```shellscript
$ gdb
gdb> set architecture mips
gdb> set endian little
gdb> target remote <host>:<port>

# eg.
gdb> target remote 8.8.8.8:8888
```

#### 6.6.4 Attempting to overwrite return address

Refer to the following disassembly snippet:

```mipsasm
41f900:       afbf0060        sw      ra,96(sp)
...
41f994:       02202021        move    a0,s1
41f998:       0320f809        jalr    t9
```

In an attempt to overwrite the return address to invoke an RCE, we first have to identify the address stored in the `s1` (location we write) register, and the location where `ra` (return address to overwrite) is saved

To achieve this, we can can print the values of each register at specific instructions:

1. `ra` can be found at address `$sp+96` as seen from instruction **41f900**
2. `s1` @ right before **41f994**

* The value stored in `s1` is written to the `a0` register (1st argument to **strcat**)

**Calculate the distance between address stored in `s1` and location where `ra` is saved:**

```shellscript
# get the start of the buffer (the destination for strcat)
gdb> info register s1

# calculate the address where the return address is physically stored
gdb> p/x $sp + 96
$x = ...

# calculate distance
gdb> p/x $x - $s1
```



### 6.7 Ghidra findings

1. Window -> Function call graph
2. Window -> Function call tree
3. Window -> Defined strings
   1. Right-click  -> Data -> ... eg. TerminatedCString
   2. Right-click -> References -> show TerminatedCstring
4. Right-click -> References -> show references to ...
5. ...



<figure><img src="../../../.gitbook/assets/image (125).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (124).png" alt=""><figcaption></figcaption></figure>



```
HTTP POST /apply_cgi
   ↓
apply_cgi()
   ↓
get_cgi("skip_amd_check")   ← optional bypass
get_cgi("<action_var>") == "Apply"
   ↓
for each entry in variables[]:
    if get_cgi(variable_name):
        variable_handler()
            ↓
            get_merge_ipaddr()

```

```http
POST /apply_cgi HTTP/1.1
Content-Type: application/x-www-form-urlencoded

action=Apply&lan_ipaddr=AAAA...
```

