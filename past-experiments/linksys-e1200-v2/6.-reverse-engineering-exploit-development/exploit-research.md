# Exploit research

### 6.4 Initial findings

```shellscript
$ pwn checksec gn-httpd
[*] '/home/user/linksys-e1200-v2/gn-httpd'
    Arch:     mips-32-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x400000)
    RWX:      Has RWX segments
```

We can see that the `gn-httpd` binary does not have any form of protection

### 6.5 Ghidra

#### `get_merge_ipaddr`

<figure><img src="../../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

```c
undefined4 get_merge_ipaddr(undefined4 param_1,char *param_2)

{
  char *__src;
  size_t sVar1;
  int iVar2;
  char acStack_48 [32];
  
  *param_2 = '\0';
  iVar2 = 0;
  while( true ) {
    snprintf(acStack_48,0x1e,"%s_%d",param_1,iVar2);
    __src = (char *)get_cgi((ACTION)acStack_48);
    if (__src == (char *)0x0) {
      __src = "0";
    }
    strcat(param_2,__src);
    if (iVar2 == 3) break;
    iVar2 = iVar2 + 1;
    sVar1 = strlen(param_2);
    param_2[sVar1] = '.';
    (param_2 + sVar1)[1] = '\0';
    if (iVar2 == 4) {
      return 1;
    }
  }
  return 1;
}

```

#### Refined `get_merge_ipaddr`

```
```

...

#### Analysis of the disassembly

> Keep in mind that we are working with the MIPS assembly for this binary. The insrtuctions and concepts are different from common x86, x64 or ARM assembly

It appears that Ghidra maps the register values `a0`, `a1`, `an`, to `param_1`, `param_2`, `param_n` respectively

...



**For the following C line**:

```c
strcat(param_2,__src);
```

```mipsasm
  41f98c:       8f998938        lw      t9,-30408(gp)
  41f990:       10400022        beqz    v0,41fa1c <get_merge_ipaddr@@Base+0x12c>
  41f994:       02202021        move    a0,s1
  41f998:       0320f809        jalr    t9
  41f99c:       00402821        move    a1,v0
  41f9a0:       8fbc0018        lw      gp,24(sp)
  41f9a4:       24020003        li      v0,3
  41f9a8:       8f9981b0        lw      t9,-32336(gp)

```

> Note that Ghidra converts the register values **a0**, **a1**, **an** to **param\_1**, **param\_2**, **param\_n** respectively

**Tracing the memory location of the `s1` variable**

```mipsasm
  41f994:       02202021        move    a0,s1
```

...

```mipsasm
0041f91c44 00       sw       s1,local_24(sp)
b1 af

```

...

#### get\_cgi

```c
```



### 6.6 `gdb`, `gdbserver`&#x20;

{% embed url="https://docs.hex-rays.com/user-guide/debugger/remote-debugging/remote-gdb-debugger/debugging-with-gdbserver" %}

{% embed url="https://gcc.gnu.org/onlinedocs/gcc-4.8.5/gnat_ugn_unw/Remote-Debugging-using-gdbserver.html" %}

#### 6.6.1 Compile `gdbserver` for the target's architecture

{% embed url="https://github.com/guyush1/gdb-static" %}

To start off, we have to retrieve the `gdbserver` binary for our target architecture **mipsel** (_mips little-endian_):

{% code overflow="wrap" %}
```shellscript
$ wget https://github.com/guyush1/gdb-static/releases/download/v17.1-static/gdb-static-full-mipsel.tar.gz

$ tar -xzvf gdb-static-full-mipsel.tar.gz
$ ls 
addr2line gdb        objdump    strings
ar        gdbserver  objcopy    ...
as        ld          readelf    ...
```
{% endcode %}

Due to limited space on the device, we can only store a few selected binaries at once. In this case, this will be `gdbserver`.

> Remember to always check the available memory space available on the device, before transferring files

#### 6.6.2 `gdbserver` on target router

Next, we can run `gdbserver` on the target router:

> We can use the steps outlined in the previous steps to transfer the `gdbserver` binary from host to the device

{% code title="UART console" %}
```console
# gdbserver localhost:<port> <program>

#! eg. 
# gdbserver localhost:8888 /path/to/httpd
```
{% endcode %}

Alternatively, launch from PID of a running program:

{% code title="UART console" %}
```console
# gdbserver localhost:<port> --attach <PID_of_program>

#! eg.
# pidof httpd
# gdbserver localhost:8888 --attach <PID>
```
{% endcode %}

#### 6.6.3 Connect to remote target from host machine

* To debug (using `gdb`) from the host machine
  * Since we know that our router uses the `mipsel` architecture (simply `mips` with _little-endian_), we have to set it up appropriately

```shellscript
$ gdb
gdb> set architecture mips
gdb> set endian little
gdb> target remote <host>:<port>

# eg.
gdb> target remote 8.8.8.8:8888
```

### 6.7 xxxx

...
