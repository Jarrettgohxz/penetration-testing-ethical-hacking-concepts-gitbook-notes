# CVE-2025-60691

...

### 1. Ghidra&#x20;

{% file src="../../../../.gitbook/assets/apply_cgi.c" %}

#### `apply_cgi` function

* Only the relevant code portions to the CVE is shown

```c
undefined4
apply_cgi(FILE *param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,
         char *param_6,char *param_7)

{
  char *pcVar1;
  int iVar2;
  char *__s1;
  char *pcVar3;
  FILE *__stream;
  undefined4 uVar4;
  undefined **ppuVar5;
  undefined1 *puVar6;
  uint __seconds;
  char local_838;
  undefined1 auStack_837 [2047];
  char *local_38;
  int local_34;
  int local_30;
  
  pcVar1 = (char *)get_cgi(0x49f270);
  if (pcVar1 == (char *)0x0) {
    pcVar1 = "0";
  }
  local_30 = atoi(pcVar1);
  pcVar1 = (char *)get_cgi(0x49f188);
  if (pcVar1 == (char *)0x0) {
    pcVar1 = "1";
  }
  local_34 = atoi(pcVar1);
  local_38 = (char *)get_cgi(0x49f27c);
  error_value = 0;
  pcVar1 = (char *)get_cgi(0x49f288);
  if (pcVar1 == (char *)0x0) {
    pcVar1 = "";
  }
  iVar2 = strcmp(pcVar1,"gozila_cgi");
  if (iVar2 == 0) {
    gozila_cgi(param_1);
    return 1;
  }
  __s1 = (char *)get_cgi(0x49edc0);
  if (__s1 == (char *)0x0) {
    __s1 = "";
    if (param_7 != (char *)0x0) goto LAB_00421bc0;
LAB_00421d74:
    puVar6 = (undefined1 *)0x0;
    __seconds = 0;
  }
  else {
    if (param_7 == (char *)0x0) goto LAB_00421d74;
LAB_00421bc0:
    if (param_6 != (char *)0x0) {
      iVar2 = strcmp(param_6,"tmBlock.cgi");
      if (iVar2 == 0) {
        local_838 = '\0';
        memset(auStack_837,0,0x7ff);
        iVar2 = get_cgi(0x4a2600);
        sprintf(&local_838,"http://%s",iVar2);
        nvram_set("TM_block_url",&local_838);
        iVar2 = get_cgi(0x4a35cc);
        nvram_set("TM_block_index",iVar2);
        iVar2 = get_cgi(0x4a1474);
        nvram_set("TM_block_hwaddr",iVar2);
        pcVar1 = (char *)get_cgi(0x49f2ec);
        if ((pcVar1 == (char *)0x0) || (iVar2 = strcmp(pcVar1,"1"), iVar2 != 0)) {
          do_ej("tmWTPBlock.asp",param_1);
        }
        else {
          do_ej("tmPCBlock.asp",param_1);
        }
        wfflush(param_1);
        return 1;
      }
      iVar2 = strcmp(param_6,"hndBlock.cgi");
      if (iVar2 == 0) {
        local_838 = '\0';
        memset(auStack_837,0,0x7ff);
        iVar2 = get_cgi(0x4a2600);
        sprintf(&local_838,"http://%s",iVar2);
        nvram_set("hnd_block_url",&local_838);
        iVar2 = get_cgi(0x49bfd0);
        nvram_set("hnd_block_policy",iVar2);
        iVar2 = get_cgi(0x4a1474);
        nvram_set("hnd_block_mac",iVar2);
        iVar2 = get_cgi(0x49f6a0);
        nvram_set("hnd_block_ip",iVar2);
        pcVar1 = (char *)get_cgi(0x49f2ec);
        if ((pcVar1 == (char *)0x0) || (iVar2 = strcmp(pcVar1,"0"), iVar2 != 0)) {
          do_ej("BlockSite.asp",param_1);
        }
        else {
          do_ej("BlockTime.asp",param_1);
        }
        nvram_set("hnd_password_deny",&DAT_0049ea84);
        wfflush(param_1);
        return 1;
      }
    }

...
```

* From previous fuzzing steps, we know that we can reach the `apply_cgi` function with the simple HTTP request (other headers and parameters redacted):

```http
POST /apply.cgi
```

### 2. Analysis of the source code

#### 2.1 Analysis of the `apply_cgi` function&#x20;

1. From the `apply_cgi` function earlier, we can understand the following:

a. Function arguments

```c
apply_cgi(FILE *param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,
         char *param_6,char *param_7)
```

b. Values required for the variables, in order for the control flow to reach the vulnerable code portion

```c
 //... variable declaration portion
 
 pcVar1 = (char *)get_cgi(0x49f270);
  if (pcVar1 == (char *)0x0) {
    pcVar1 = "0";
  }
  local_30 = atoi(pcVar1);
  pcVar1 = (char *)get_cgi(0x49f188);
  if (pcVar1 == (char *)0x0) {
    pcVar1 = "1";
  }
  local_34 = atoi(pcVar1);
  local_38 = (char *)get_cgi(0x49f27c);
  error_value = 0;
  pcVar1 = (char *)get_cgi(0x49f288);
  if (pcVar1 == (char *)0x0) {
    pcVar1 = "";
  }
  iVar2 = strcmp(pcVar1,"gozila_cgi");
  if (iVar2 == 0) {
    gozila_cgi(param_1);
    return 1;
  }
  __s1 = (char *)get_cgi(0x49edc0);
  if (__s1 == (char *)0x0) {
    __s1 = "";
    if (param_7 != (char *)0x0) goto LAB_00421bc0;
LAB_00421d74:
    puVar6 = (undefined1 *)0x0;
    __seconds = 0;
  }
  else {
    if (param_7 == (char *)0x0) goto LAB_00421d74;
LAB_00421bc0:
    if (param_6 != (char *)0x0) {
    
    // ...vulnerable code portion
```

_**get\_cgi**_ calls

1. String value@`0x49f270` -> **need\_reboot**

* No requirements

```c
pcVar1 = (char *)get_cgi(0x49f270);
```

2. String value@`0x49f188` -> **commit**

* No requirements

```c
pcVar1 = (char *)get_cgi(0x49f188);
```

3. String value@`0x49f288` -> **change\_action**

* Must not be the value _gozila\_cgi_

```c
pcVar1 = (char *)get_cgi(0x49f288);
...
iVar2 = strcmp(pcVar1,"gozila_cgi");
if (iVar2 == 0) {
    gozila_cgi(param_1);
    return 1;
}
```

4. String value@`0x49dec0` -> **submit\_button**
   * Must be a NULL pointer (not defined in the request)

```c
__s1 = (char *)get_cgi(0x49edc0);
  if (__s1 == (char *)0x0) {
  ...
  if (param_7 != (char *)0x0) goto LAB_00421bc0;
    ...
    LAB_00421bc0:
        if (param_6 != (char *)0x0) {
        ...
  }
```

* `param_6` and `param_7` must NOT be a NULL pointer
* `param_6` must contain the value of either _tmBlock.cgi_ or _hndBlock.cgi_<br>

#### 2.2 Analysis of the `index.asp` file

> Refer to the Exploit research page for more information on the `index.asp` file

1. **`apply.cgi` action**

The following shows a code snippet of the form field involving the `apply.cgi` action in the `index.asp` file&#x20;

{% code title="index.asp" %}
```razor
</SCRIPT>
</HEAD>
<BODY onload=init() onunload=exit()>
<FORM name=setup method=<% get_http_method(); %> action=apply.cgi>
<input type=hidden name=submit_button>
<input type=hidden name=change_action>
<input type=hidden name=submit_type>
<input type=hidden name=action>
<input type=hidden name=now_proto value='<% nvram_gozila_get("wan_proto"); %>'>
<input type=hidden name=daylight_time value=0>
<input type=hidden name=switch_mode_dhcp value=<% nvram_get("switch_mode_dhcp");%>>
<input type=hidden name=switch_mode value=<% nvram_gozila_get("switch_mode");%>>
<input type=hidden name="switch_ipaddr" value="4">
<input type=hidden name=hnap_devicename value=<% nvram_get("hnap_devicename");%>>
<input type=hidden name="need_reboot" value="0">
<input type=hidden name=user_language>
<input type=hidden name="wait_time" value="0">
<input type=hidden name=dhcp_start value=<% nvram_get("dhcp_start");%>>
<% support_invmatch("HNAP_SPEC_V12_SUPPORT", "1", "<!--"); %>
<input type=hidden name=dhcp_start_conflict value=0>
<% support_invmatch("HNAP_SPEC_V12_SUPPORT", "1", "-->"); %>
<input type=hidden name="lan_ipaddr" value="4">
<input type=hidden name=ppp_demand_pppoe value="9">
<input type=hidden name=ppp_demand_pptp value="9">
<input type=hidden name=ppp_demand_l2tp value="9">
<input type=hidden name=ppp_demand_hb value="9">
<input type=hidden name=wan_ipv6_proto>
<% nvram_invmatch("wan_ipv6_proto", "tunnel", "<!--"); %>
<input type=hidden name=tunnel_status value="connecting">
<% nvram_invmatch("wan_ipv6_proto", "tunnel", "-->"); %>
...

```
{% endcode %}

From the `index.asp` file, we can identify a few potential HTTP parameters:

* **submit\_button**
* **change\_action**
* **submit\_type**
* **action**
* etc.

> Refer to the notes under the _Exploit research_ page to understand how we can control the web page to trigger the `apply_cgi` function

#### 2.3 Likely HTTP POST request format

```http
POST /apply.cgi HTTP/1.1
Host: <addr>:80
Content-Type: application/x-www-form-urlencoded
Authorization: Basic [Auth]

// ...POST_PARAMETERS HERE
```

**POST parameter values**

As we understand from the analysis before, we have to set the following values in order to control the flow in our way:

1. `change_action`

* Must NOT be equal to the value **gozila\_cgi**

2. `submit_button`

* Must be a NULL pointer (not defined)

3. `param_6`&#x20;

* Likely taken from the **action** parameter
* Must NOT be a NULL pointer
  * Either **tmBlock.cgi** or **hdnBlock.cgi**

4. `param_7`

* Likely taken from the **submit\_type** parameter
* Must NOT be a NULL pointer
  * Can be an empty string

{% code overflow="wrap" %}
```http
change_action=&action=tmBlock.cgi&submit_type=&url=[BUFFER OVERFLOW PAYLOAD]
```
{% endcode %}

### 3. Network analysis + reverse engineering&#x20;

#### 3.1 Network analysis

It is likely that the `index.asp` file is loaded whenever a request is sent to the root URL of the webpage on port 80. We know that there exist a form element that calls the `apply.cgi` route, which triggers the `apply_cgi` function

**3.1.1 Manually send form request from the webpage**

We can manually send a form request, and use the web browser to analyze the HTTP traffic to understand the parameters and values involved

> Refer to the notes under the _Exploit research_ page to understand more about each function discussed below

**Payload analysis**

* The following outlines the payload for each of the specific forms:

**(1) selWAN() function**

* Relevant code snippet
  * Search "FUNNAME1" in web browser code inspector tool

{% code overflow="wrap" %}
```html
<TD colspan=2 class=FUNNAME1><SELECT name="wan_proto" onChange=SelWAN(this.form.wan_proto.selectedIndex,this.form)>
...
```
{% endcode %}

* We can find the following form section on the web page:

<figure><img src="../../../../.gitbook/assets/webpage_automatic-configuration-select-2 (1).png" alt=""><figcaption></figcaption></figure>

* Next, we can experiment with a few values from the selection options, and record the _Payload parameters_ (form-data) that are automatically generated by the code, and sent with the request

> NOTE: we require proper authentication with the `Authorization: Basic xxxx` request headers, and the response should have a **200 OK** status code

**a. Automatic Configuration - Static IP**

{% code overflow="wrap" %}
```
submit_button        index
change_action        gozila_cgi
submit_type
action
now_proto            dhcp
daylight_time        0
switch_mode_dhcp     1
switch_mode          0
switch_ipaddr        4
hnap_devicename      Cisco58059
need_reboot          0
user_language
wait_time            0
dhcp_start           100
dhcp_start_conflict  0
lan_ipaddr           4
ppp_demand_pppoe     9
ppp_demand_pptp      9
ppp_demand_l2tp      9
ppp_demand_hb        9
wan_ipv6_proto
detect_lang          EN
wan_proto            static
wan_hostname
wan_domain
mtu_enable           0
lan_ipaddr_0         192
lan_ipaddr_1         168
lan_ipaddr_2         1
lan_ipaddr_3         1
lan_netmask          255.255.255.0
machine_name         Cisco58059
lan_proto            dhcp
dhcp_check
dhcp_start_tmp       100
dhcp_num             50
dhcp_lease           0
wan_dns              4
wan_dns0_0           0
wan_dns0_1           0
wan_dns0_2           0
wan_dns0_3           0
wan_dns1_0           0
wan_dns1_1           0
wan_dns1_2           0
wan_dns1_3           0
wan_dns2_0           0
wan_dns2_1           0
wan_dns2_2           0
wan_dns2_3           0
wan_wins             4
wan_wins_0           0
wan_wins_1           0
wan_wins_2           0
wan_wins_3           0
time_zone            -08 1 1
_daylight_time       1

```
{% endcode %}

**b. Automatic Configuration - DHCP**

```
submit_button        index
change_action        gozila_cgi
submit_type
action
now_proto            static
daylight_time        0
switch_mode_dhcp     1
switch_mode          0
switch_ipaddr        4
hnap_devicename      Cisco58059
need_reboot          0
user_language
wait_time            0
dhcp_start           100
dhcp_start_conflict  0
lan_ipaddr           4
ppp_demand_pppoe     9
ppp_demand_pptp      9
ppp_demand_l2tp      9
ppp_demand_hb        9
wan_ipv6_proto
detect_lang          EN
wan_proto            dhcp
wan_ipaddr           4
wan_ipaddr_0         0
wan_ipaddr_1         0
wan_ipaddr_2         0
wan_ipaddr_3         0
wan_netmask          4
wan_netmask_0        0
wan_netmask_1        0
wan_netmask_2        0
wan_netmask_3        0
wan_gateway          4
wan_gateway_0        0
wan_gateway_1        0
wan_gateway_2        0
wan_gateway_3        0
wan_dns              3
wan_dns0_0           0
wan_dns0_1           0
wan_dns0_2           0
wan_dns0_3           0
wan_dns1_0           0
wan_dns1_1           0
wan_dns1_2           0
wan_dns1_3           0
wan_dns2_0           0
wan_dns2_1           0
wan_dns2_2           0
wan_dns2_3           0
wan_hostname
wan_domain
mtu_enable           0
lan_ipaddr_0         192
lan_ipaddr_1         168
lan_ipaddr_2         1
lan_ipaddr_3         1
lan_netmask          255.255.255.0
machine_name         Cisco58059
lan_proto            dhcp
dhcp_check
dhcp_start_tmp       100
dhcp_num             50
dhcp_lease           0
wan_dns              4
wan_wins             4
wan_wins_0           0
wan_wins_1           0
wan_wins_2           0
wan_wins_3           0
time_zone            -08
_daylight_time       1
```

...

#### 3.2 Analysis with GDB+gdbserver

Now that we have identified the HTTP POST request format and the payload for each specific requests, we can attempt to identify the likely parameters corresponding to the `param_6` and `param_7` parameters

Using the [GDB+gdbserver setup](https://jarrettgxz-sec.gitbook.io/penetration-testing-ethical-hacking-concepts/past-experiments/linksys-e1200-v2/5.-reverse-engineering-exploit-development/exploit-research#id-2.-gdb-gdbserver), we can set breakpoints on relevant portions of the code to analyze the behavior of each HTTP request with different payloads



1. **Set software (and also hardware) breakpoints in GDB**

issues likely due to the router limitations...



2. **Manual patching of the `httpd` program with a break point (start of `apply_cgi` function)**

```shellscript
gef> info proc mappings

Start Addr   End Addr     Size      Offset   Perms   objfile
 0x400000    0x4b4000     0xb4000   0x0       r-xp   /tmp/httpd
 0x4f4000    0x4fa000     0x6000    0xb4000   rw-p   /tmp/httpd
```

* Notice the start address value `0x400000`

**Points to note**:

* `\x0d\x00\x00\x00` represents the value `0x0000000d` in little-endian, which is a `break` instruction
* We willl overwrite the address at `0x4000000` - `0x421a10` = `0x21a10`&#x20;
  * Offset from the start address
  * Indicated by the **seek** option

```shellscript
$ cp <path-to-current-httpd> /tmp/httpd
$ printf '\x0d\x00\x00\x00' | dd of=/tmp/httpd bs=1 seek=$((0x21a10)) conv=notrunc
```

Next, we can use the UART console on the router to retrieve the patched binary, and update the process

* We also need to kill the current `httpd` process and start a new one with the patched version

{% code title="UART console" %}
```console
# wget http://<host>:<port>/httpd -O /tmp/httpd
# chmod +x /tmp/httpd
# ps w | grep httpd
 325 root       xxxx S   /tmp/httpd
 
# kill -9 325
# /tmp/httpd
# /tmp/gdbserver <host>:<port> /tmp/httpd
```
{% endcode %}

From the host machine running `gdbserver`:

```shellscript
$ gdb-multiarch

gdb> set arch mips
gdb> set endian little
gdb> target remote <host>:<port>
(remote) gdb>  set follow-fork-mode child
(remote) gdb>  set detach-on-fork off

(remote) gdb> continue
```

**Note on commands**

* The `httpd` web server forks each time a new request is received, such as when a call to `apply.cgi` is made
* The `set follow-fork-mode child` and `set detach-on-fork off` commands are used to aid us in separating the child (fork) and parent process when we are debugging

**Error**

* An error right after the `continue` command is executed, even before any HTTP request is being sent. This is likely due to a certain health check on the `apply_cgi` function right at the initialization of the program



3. **Manual patching of the `httpd` program with an infinite loop**

* From the previous analysis, we know that a break point at the start of the `apply_cgi` function causes the program to crash early
* Instead, we can use an infinite loop

**Points to note**:

* `\xA8\x44\x10\x08` represents the MIPS instruction `j 0x00421a10` in machine code

```shellscript
$ printf '\xA8\x44\x10\x08 ' | dd of=/tmp/httpd bs=1 seek=$((0x21a10)) conv=notrunc
```

Following the same steps as above, the program simply hangs when a request is being sent (refer to the _**Testing payload**_ section below).&#x20;

This is expected behavior from the infinite loop. A subsequent `ctrl+c` command is expected to pause the execution and allow us to interact with the register and stack at the current instruction. However, the program simply exits when `ctrl+c` is called

This is also likely due to the certain health check mentioned earlier



4. **Manual patching of the `httpd` program with a break point (middle of `apply_cgi` function) + attach gdbserver to PID**

Let's attempt to set a break point slightly later in the `apply_cgi` function, in hopes that the initialization process (health check, etc.) will not reach that particular instruction



```console
# ps w | grep httpd
 <new-PID> root       xxxx S   /tmp/httpd
# /tmp/gdbserver <host>:<port> --attach <new-PID>
```

Attaching gdbserver to an already running process prevents any health check during the initialization steps from interfering with the patched instructions

**...**



#### 3.1 Testing payload

```shellscript
# ...
$ cat cve-2025-60691-payload.txt
...

$ printf "$(cat cve-2025-60691-payload.txt)" | nc -C 192.168.1.1 80
...
```

### 4. Analysis in Ghidra

#### 4.1 Search for value "apply\_cgi"

* From header tab: Search&#x20;

a. Search "For Strings..."

b. Search "For Direct References"

c. Search  "Program Text"

d. Search "Memory"

e. XREFs

* Finding all references to the <kbd>`apply_cgi`</kbd> function
* Right click on function name -> References -> Find References to apply\_cgi

The only useful reference is found as a _DATA_ from the `router_upgrade` function

* The `apply_cgi` function itself is not even called within this function

<figure><img src="../../../../.gitbook/assets/unknown (2) (1).png" alt=""><figcaption></figcaption></figure>

#### 4.2 Search for value "apply.cgi"

* From header tab: Search&#x20;

a. Search "For Strings..."

* Section under the **.rodata**

<figure><img src="../../../../.gitbook/assets/unknown.png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../../.gitbook/assets/unknown (2).png" alt=""><figcaption></figcaption></figure>

b. Search "For Direct Reference

* None found

c. Search  "Program Text"

* None found

d. Search "Memory"

...

e. XREFs

...



### 5. Google dork



We can perform a Google dork to discover other vulnerabilities found on Linksys router for the `httpd` binary, specifically for any`.cgi` functions:

```
linksys httpd "cve" "*.cgi"
linksys httpd "cve" "apply.cgi"
```

...

