# x86 assembly (32-bit)

### Basics

1. `add`&#x20;

```nasm
add arg1, arg2 ; arg1 = arg + arg2 
```

2. `sub`&#x20;

```nasm
sub arg1, arg2 ; arg1 = arg1 - arg2
```

3. `push`/`pop`&#x20;

```nasm
push arg ; place the operand (arg) onto the top of the stack in memory
```

* Decrements ESP by 4 (_stack grows from high to low addresses_)
* Place the operand into the content of the 32-bit location at address \[ESP]

4. `lea` (load effective address)

{% code overflow="wrap" %}
```nasm
lea <reg32>,<mem> ; places the address specified by second operand into the register specified by its first operand
```
{% endcode %}

> Note, the _contents_ of the memory location are not loaded, only the effective address is computed and placed into the register. This is useful for obtaining a pointer into a memory region.

5. `cmp`&#x20;

```nasm
cmp arg1, arg2 ; compares arg1 and arg2, and update the "flag" accordingly
```

* Used in conjunction with _jump instructions_

6. **jump instructions**

* Used in conjunction with `cmp`

**5.1 Jump**

* Transfers program control flow to the instruction at the memory location indicated by the operand

{% code overflow="wrap" %}
```nasm
jmp <label> ; jump to the instruction labeled <label> without checking for conditions
```
{% endcode %}

**5.2 Conditional jump**

```nasm
je <label> ; jump when equal
jne <label> ; jump when not equal
jz <label> ; jump when last result was zero
jg <label> ; jump when greater than
jge <label> ; jump when greater than or equal to
jl <label> ; jump when less than
jle <label> ; jump when less than or equal to
```



6. `call`, `ret`

```nasm
```

