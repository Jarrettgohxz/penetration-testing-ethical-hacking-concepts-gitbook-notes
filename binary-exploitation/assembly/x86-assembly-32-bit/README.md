# x86 assembly (32-bit)

### Basics

1. `add`&#x20;

```nasm
add arg1, arg2 ; arg1 = arg + arg2 
```

2. `sub`&#x20;

```nasm
sub arg1, arg2 ; arg1 = arg1 - arg2
```

3. `push`/`pop`&#x20;

**3.1 Push**

```nasm
push arg ; place the operand (arg) onto the top of the stack in memory
```

* Decrements ESP by 4 (_stack grows from high to low addresses_)
* Place the operand into the content of the 32-bit location at address \[ESP]

4. `lea` (load effective address)

{% code overflow="wrap" %}
```nasm
lea <reg32>,<mem> ; places the address specified by second operand into the register specified by its first operand
```
{% endcode %}

> Note, the _contents_ of the memory location are not loaded, only the effective address is computed and placed into the register. This is useful for obtaining a pointer into a memory region.

**3.2 Pop**

**...**



5. `cmp`&#x20;

```nasm
cmp arg1, arg2 ; compares arg1 and arg2, and update the "flag" accordingly
```

* Performs operations to update the **EFLAGS** register

{% embed url="https://jarrettgxz-sec.gitbook.io/penetration-testing-ethical-hacking-concepts/binary-exploitation/computer-architecture/instruction-set-architecture-isa/x86-architecture" %}

* Used in conjunction with _jump instructions_

6. **jump instructions**

* Used in conjunction with `cmp`

**5.1 Jump**

* Transfers program control flow to the instruction at the memory location indicated by the operand

{% code overflow="wrap" %}
```nasm
jmp <label> ; jump to the instruction labeled <label> without checking for conditions
```
{% endcode %}

**5.2 Conditional jump**

```nasm
je <label> ; jump when equal
jne <label> ; jump when not equal
jz <label> ; jump when last result was zero
jg <label> ; jump when greater than
jge <label> ; jump when greater than or equal to
jl <label> ; jump when less than
jle <label> ; jump when less than or equal to
```

6. `call`, `ret`

```nasm
call <label>
; same as:
push eip
jmp <label>
```

```nasm
<label>: ...
        ...
        ret 
        

; ret command same as (TO CONFIRM):
pop <reg>
jmp <reg>
```

* **call**

a. First, _**push**_ the current code location on the stack in memory (`push`)

b. Next, performs an unconditional jump to the code location indicated by the label operand (`jmp`)

> Unlike the simple jump instructions, the call instruction saves the location to return to when the subroutine completes.

* **ret**

> Implements a subroutine return mechanism

a. First, _**pops**_ a code location off the stack (`pop`)

b. Next, performs an unconditional jump to the retrieved code location (`jmp`)

