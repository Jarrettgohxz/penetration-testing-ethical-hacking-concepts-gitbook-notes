# Common

### 1. Function calls

#### General overview of steps

1. Push function (to call) arguments to the stack
2. Load function address in the `EIP`&#x20;

* Save current `EIP` before updating it to point to new function address

3. Move `EBP` to bottom of new stack frame

* Save current `EBP` before updating it to point to current value in `ESP`&#x20;

4. Allocate space for the new stack frame

* Move `ESP` down (to lower address)

5. Execute function
6. Erase the stack frame used by the function

* Increment `ESP` to point to the top of the stack frame (`EBP`)

7. Restore `EBP` and `EIP`&#x20;
8. Remove arguments from stack

* Increment `ESP`

{% embed url="https://textbook.cs161.org/memory-safety/x86.html#28-x86-function-calls" %}

Following the steps outlined in the textbook above regarding function calls, I will list out the corresponding **x86** (32-bit) assembly codes. Note that for this example, we will draw the memory layout with the highest address at the _**top**_, while the lower addresses appear at the _**bottom**_ visually. However, the `EBP` and `ESP` will still point to the higher and lower addresses of the stack frame respectively.

#### 1.1 Push arguments on the stack

> Remember that **x86** passes arguments by pushing them onto the stack&#x20;

**State of the memory BEFORE**

<figure><img src="../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

**State of the memory AFTER instruction**

```nasm
push arg1 ; push first arg1 to stack
push arg2 ; push second arg2 to stack
```

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

* As we can see from the stack content after the instruction, `arg2` is pushed first before `arg1`. This is because arguments are pushed onto the stack in reverse order

#### 1.2 Call the function

* This step can be broken down into 2 separate assembly commands: `push` and `jmp`

#### 1.2.1 Push the old `EIP` on the stack

* Since the value in the `EIP` register will be changed to point to the function address, we need to save its current value onto the stack before we overwrite it with a new value

**State of the memory AFTER instruction**

```nasm
push eip
```

<figure><img src="../../.gitbook/assets/image (68).png" alt=""><figcaption></figcaption></figure>

#### 1.2.2 `jmp` to the function address

```nasm
jmp <func_addr>
```

**State of the memory AFTER instruction**

The above `jmp` instruction simply points the `EIP` to the address given as argument. In this case, it will be the address of the "test" function.

<figure><img src="../../.gitbook/assets/image (69).png" alt=""><figcaption></figcaption></figure>

#### 1.3 Save current `EBP` value, before updating to point to new stack frame

* This step can be broken down into 2 steps, first we push the `EBP` to the stack, before copying the value of the current `ESP` to the `EBP`&#x20;

#### 1.3.1 Push current `EBP` to stack

```nasm
push ebp
```

<figure><img src="../../.gitbook/assets/image (70).png" alt=""><figcaption></figcaption></figure>

#### 1.3.2 Copy value of `ESP` to `EBP`

```nasm
mov ebp, esp
```

Now, the `EBP` will point to the same address referenced by the `ESP` :

<figure><img src="../../.gitbook/assets/image (71).png" alt=""><figcaption></figcaption></figure>

This will allow the `EBP` to point to the **bottom** (or **top** if seen visually from this diagram â€” remember the drawing convention in this example) of the (higher address) of the new stack frame of the "test" function.

#### 1.4 Allocate new space for the new stack

* This is performed by growing the stack (moving the `ESP` to the lower address). The compiler will decide how far the `ESP` should be decremented, based on the complexity of the function to be called. In this example, we will assume the `ESP` is decremented by 8 bytes:

```nasm
sub esp, 0x8
```

<figure><img src="../../.gitbook/assets/image (72).png" alt=""><figcaption></figcaption></figure>

...





