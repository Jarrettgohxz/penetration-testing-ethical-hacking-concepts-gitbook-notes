# x86 (32-bit) VS x64 (64-bit)

{% embed url="https://guyinatuxedo.github.io/01-intro_assembly/assembly/index.html" %}

### 1. General comparisons

|                                                                       | x86                 | x64                  |
| --------------------------------------------------------------------- | ------------------- | -------------------- |
| How are arguments passed to functions in an ELF (Linux) architecture? | Passed on the stack | Passed via registers |
| Which register is used to return a value from a C function?           | `eax` register      | `rax` register       |
| Maximum register size                                                 | 4 byte (32 bit)     | 8 byte (64 bit)      |
| ...                                                                   |                     |                      |

### 2. Registers

As mentioned before, the `x64` architecture has 8 byte registers, while `x86` can only access up to the 4 byte registers. There also exists 2 byte and a single byte register, as defined in the table below:

> Taken directly from [source](https://guyinatuxedo.github.io/01-intro_assembly/assembly/index.html)&#x20;

<div data-with-frame="true"><figure><img src="../../../.gitbook/assets/image (3) (1) (1) (1).png" alt=""><figcaption></figcaption></figure></div>

Taking the 8 byte register `rax` as an example, we can see that the lower 4, 2 and single byte(s) register will be the `eax`, `ax` and `al` respectively.

* `eax`: Lower 4 bytes of the `rax` register
* `ax`: Lower 2 bytes of the `rax` register
* `al`: Last byte of the `rax` register<br>

### 3. Passing of arguments to functions

As discussed before, we know that **x86** architecture passes arguments to functions via the stack, while **x64** does it via registers (`rdi`, `rsi`, `rdx`, etc.). In this section, we will discuss examples of how this can be achieved

#### x86 (via stack)

Most compilers have the convention of storing the argument value in the `eax`, `ebx`<sub>`,`</sub>`ecx`<sub>,</sub> etc. registers (depending on the number of arguments) temporarily, right before the values are pushed to the stack

* In the example below, the `function_to_call` function receives two arguments: **2** and **22**:

```asm
mov eax, 2       ; first argument
push eax         ; push first argument onto stack
mov ebx, 22      ; second argument
push ebx         ; push second argument onto stack
call function_to_call
```

#### x64 (via registers)

Function arguments are passed via the following registers: `rdi`, `rsi`, `rdx`, `rcx`, `r8`, `r9` (1st to 6th argument)

* In the example below, the `function_to_call` function receives two  arguments: **2** and **22**:

```asm
mov rdi, 2      ; first argument
mov rsi, 22     ; second argument
call function_to_call
```

