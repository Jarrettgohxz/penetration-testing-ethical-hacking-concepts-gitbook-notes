# MIPS (32-bit)

## Delay slots

{% embed url="https://users.cs.duke.edu/~narten/110/nachos/main/node37.html" %}

In the MIPS architecture, **control-flow instructions** such as branches and jumps have an architectural _**delay slot**_. This means that the instruction immediately following a branch or jump is always executed, regardless of whether the branch is taken or where the jump transfers control

This behavior exists due to the MIPS pipeline design, where the instruction following a control-flow change has already been fetched and is allowed to complete execution before the program counter (PC) is updated

As a result, the branch or jump instruction and its _**delay slot**_ instruction are executed as a pair. This means that the branch condition or jump target is resolved first before the _**delay slot**_ instruction executes, and only then does the control flow change

### Example

Given the following assembly snippet:

```mipsasm
41f990:       10400022        beqz    v0,41fa1c <get_merge_ipaddr@@Base+0x12c>
41f994:       02202021        move    a0,s1
41f998:       0320f809        jalr    t9
41f99c:       00402821        move    a1,v0
```

#### Execution flow for `beqz`

* At address **0x41f990**, the instruction tests whether register `v0` is zero:

```mipsasm
beqz v0, 41fa1c
```

* The instruction immediately following it at **0x41f994** is the _**delay slot**_ instruction for the branch:

```mipsasm
move a0, s1
```

**Execution behavior**

1. The branch condition (`v0 == 0`) is evaluated
2. The _**delay slot**_ instruction at **0x41f994** executes unconditionally
3. If `v0 == 0`, execution continues at **0x41fa1c.** Else, execution falls through to **0x41f998**

Thus, `move a0, s1` executes regardless of whether the branch is taken

#### Execution flow for `jalr`

* At address **0x41f998**, the instruction performs an indirect function call, saving the return address in `ra`:

```mipsasm
jalr t9
```

* The instruction immediately following it at **0x41f99c** is the _**delay slot**_ instruction for the jump:

```mipsasm
move a1, v0
```

**Execution behavior**

1. The return address is written to `ra`
2. The _**delay slot**_ instruction at **0x41f99c** executes unconditionally
3. Control is transferred to the address contained in register `t9`

As a result, `move a1, v0` executes before the target function is called

## Base + offset addressing

{% embed url="https://www.eecis.udel.edu/~davis/cpeg222/AssemblyTutorial/Chapter-15/ass15_6.html" %}

```mipsasm
lw   d,off(b)       # $d <-- Word from memory address b+off
                    # b is a register. off is 16-bit two's complement.
```

Register `d` will contain the value from memory address `b+off`

