# Endianness & stack growth

### Stack growth direction

a. Stack growth direction is independent of endianness, and is only dependent on the architecture

* x86, x64 stack grows from higher to lower memory addresses

### Endianness

a. The way the compiler interprets the values in the stack memory when it is read

b. Decides which byte is considered the least significant vs most significant

> NOTE: Endianness only applies when bytes are interpreted as multi-byte _numbers_ (integers, pointers, floats)
>
> * Strings will not be affected by endianess as they are are sequences of bytes, not numbers

#### Little endian

Given a hexadecimal/decimal, etc. representation:

* The value at the leftmost side of the representation will form the **MSB**, while the rightmost will form the **LSB**
* The value in the **MSB** will be placed at the _high memory address_, while the value at the **LSB** will be placed at the _low memory address_

#### Big endian

* Opposite of the little endian format

### Example

The following displays a simple C function that does the following:

1. Reads in a hex string as the 1st input

* Converts string into the base-16 (hex) representation with the `strtoul` function
* Prints the first 4 bytes in hexadecimal format



2. Reads in another string as the 2nd input, and treats it as a raw bytes string

* Prints the first 4 characters in hexadecimal format

{% code title="stack-exp.c" %}
```c
#include <stdio.h>
#include <stdint.h>
#include <unistd.h>
#include <stdlib.h>

int main(void) {
    char hexbuf[9] = {0};
    unsigned char raw[4];

    // read hex string
    read(0, hexbuf, 8);
    uint32_t num = strtoul(hexbuf, NULL, 16);

    printf("Bytes of 1st input in memory in hex format:\n");
    for (int i = 0; i < 4; i++)
        printf("%02x ", ((unsigned char *)&num)[i]);
    printf("\n");

    // read raw bytes
    read(0, raw, 4);

    printf("Bytes of 2nd input (raw bytes) in memory in hex format:\n");
    for (int i = 0; i < 4; i++)
        printf("%02x ", raw[i]);
    printf("\n");

    return 0;
}
```
{% endcode %}

#### Compile

```bash
$ gcc -o stack-exp stack-exp.c
```

* The following function simply converts the string input into the base representation: a. base 16 (hex): "1234" -> 0x1234 b. base 10 (decimal): "1234" -> 1234 c. base 8 (octal): "1234" -> 01234

```c
uint32_t num = strtoul(hexbuf, NULL, 16);
```

Eg. Raw hexadecimal input: `0x12345678`. We can use the following command on a Bash shell to provide the inputs to the C program earlier:

```bash
$ python3 - << 'EOF' | ./stack-exp
import sys
sys.stdout.buffer.write(b"12345678")
sys.stdout.buffer.write(b"\x12\x34\x56\x78")
EOF

Bytes of 1st input in memory in hex format:
78 56 34 12
Bytes of 2nd input (raw bytes) in memory in hex format:
12 34 56 78
```

* Notice the difference between the way both input values are stored in memory

> Note: the values are represented in hexadecimal format

#### Further analysis

> The binary is compiled in an x86-64 architecture -> **little endian**





Given little endian a. write 0x12345678 - 0x78 is interpreted as the LSB, 0x12 is interpreted as the MSB - 0x78 will be stored into lower memory address, 0x12 higher - when read: 0x12 higher address -> MSB, 0x78 lower address 0 -> LSB -> resulting string: 0x12345678 b. write b"\x12\x34\x56\x78" - write as the sequence given -> 0x12 stored into lower address, 0x78 stored into higher address - when read: 0x78 higher address -> MSB, 0x12 lower address -> LSB - resulting string: 0x78563412
