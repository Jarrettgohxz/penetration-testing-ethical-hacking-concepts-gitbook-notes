# GDB (gef)

GNU Debugger (GNU), with the [gef](https://github.com/hugsy/gef) wrapper to provide us with extended features.

{% embed url="https://visualgdb.com/gdbreference/commands/" %}

{% embed url="https://sourceware.org/gdb/current/onlinedocs/gdb.html/" %}

{% embed url="https://trebledj.me/posts/gdb-cheatsheet/" %}

### Commands

> [Cheatsheet](https://darkdust.net/files/GDB%20Cheat%20Sheet.pdf) link

#### 1. Run the program

* `run`, `r`

```sh
gdb <binary>
gef> run
```

#### 2. Breakpoints

**2.1** Set breakpoint on the `main` function

```sh
gef> break main
gef> b main
```

**2.2** Navigate through the program

a. `nexti`: go instruction by instruction through the program, without stepping into function calls

b. `next:` go through each line of code, without stepping into function calls

c. `stepi`: go instruction by instruction, while stepping into function calls

d. `step`:  go through each line of code, while stepping into function calls

**Summary table**

| Command | Navigate through?                                   | Step into function calls (eg. puts())? |
| ------- | --------------------------------------------------- | -------------------------------------- |
| `nexti` | Instructions                                        | NO                                     |
| `next`  | Line of code (may consist of multiple instructions) | NO                                     |
| `stepi` | Instructions                                        | YES                                    |
| `step`  | Line of code (may consist of multiple instructions) | YES                                    |

**2.3** Example on a specific instruction

* Eg. hello world function

```sh
gef> disassemble main # "disass" works too
Dump of assembler code for function main:
   xxx
   0x0804840f <+20>:	push   0x80484b0
   0x08048414 <+25>:	call   0x80482d0 <puts@plt>
   xxx
End of assembler dump.
```

* Set breakpoint on the call to `puts`

```sh
gef> break *main+25
gef> break *0x08048414
gef> break *puts
```

**2.4 Other commands**

```sh
gef> info breakpoints
gef> delete <Num> # "del" or "d" works too
```

**2.5 If Position-Independent Executable (PIE) is used**

* If PIE is present, the memory addresses of the code shown by the disassembler will not match the one actually used during runtime
* To deal with this, we can simply run the binary first, and disassemble again, to view the runtime memory addresses

```shellscript
$ readelf -h <bin_file>
...
Type:     DYN (Position-Independent Executable file)
...

$ gdb <bin_file>
gdb> starti
gdb> disass main # or whatever function desired
```

#### 3. Memory

```sh
gef> x/nfu <addresss>
```

* To print memory (refer to cheat sheet link above)
  * `n`: How many units to print (default 1)
  * `f`: Format character&#x20;
  * `u`: Unit

{% code overflow="wrap" %}
```sh
gef> x/a <address> # print pointer address

gef> x/2c <address> # print 2 characters 
gef> x/2dh <address> # print 2 decimal ('d') representation of half-words ('h': 16-bits, 2-bytes)

gef> x/s <address> # print as C string
```
{% endcode %}

#### 4. Printing

```bash
gef> ...
```



