# Ghidra

Lets use the binary from the following challenge as an example:

{% embed url="https://jarrettgxz-sec.gitbook.io/penetration-testing-ethical-hacking-concepts/reverse-engineering-binary-exploitation/buffer-overflow/stack-based-overflow/csaw-2018-quals-boi" %}

## 1. Listing view

### 1.1 Variables

<figure><img src="../../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

...

## 2. Decompile view

<figure><img src="../../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

* As we can see, there are a few issues with the decompiled code:

1. Some of the types are not defined properly (eg. `undefined8`)
2. Variables have no useful meaning
3. Values used in comparisons and assignments are not easily understood

### Example

* The following shows a basic example of how to better understand the decompiled code

#### 1. Rename variables

```c
read(0,&local_38,0x18);
```

* The `read` function reads **0x18** bytes from **stdin** into the address pointed by `local_38`&#x20;
* Its hard to understand what the variable `local_38` is used for when reading the other parts of the code
* To make it easier for ourselves, we can rename it to, for instance: `input`&#x20;
  * In **Ghidra**: right-click on variable -> Rename variable

#### 2. Retrieve actual values used by variables

```c
iStack_24 = -0x21524111; // assignment
if (iStack_24 == -0x350c4512) // comparison
```

* We can see that the code uses signed integers, which will be 2-complemented before being stored in memory
* We can use the assembly code in the _listings_ view to understood the unsigned values being used

```asm
MOV  dword ptr [RBP + local_28+0x4],0xdeadbeef ; assignment
CMP  EAX,0xcaf3baee ; comparison
```

* From here, we can understand that the assignment and comparison code uses `0xdeadbeef` and `0xcaf3baee` respectively

