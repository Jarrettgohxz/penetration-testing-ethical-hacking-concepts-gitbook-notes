# Stack view (x64)

### General understanding

For a _x64_ machine, the input value will be written from lower to higher memory addresses

> Recall that the stack will grow from higher to lower addresses (**RSP** decrements) to allocate space for new variables

#### Example

> In this example, we will be using the `boi` binary: [https://github.com/guyinatuxedo/nightmare/blob/master/modules/04-bof\_variable/csaw18\_boi/boi](https://github.com/guyinatuxedo/nightmare/blob/master/modules/04-bof_variable/csaw18_boi/boi)

Given the string input value `hello12345`, lets investigate how the input is written to the stack memory

1. Start the `boi` binary with _gdb_

```bash
$ gdb boi
gef> starti
gef> disass main
Dump of assembler code for function main:
   0x0000000000400641 <+0>:     push   rbp
   0x0000000000400642 <+1>:     mov    rbp,rsp
   0x0000000000400645 <+4>:     sub    rsp,0x40
   0x0000000000400649 <+8>:     mov    DWORD PTR [rbp-0x34],edi
   0x000000000040064c <+11>:    mov    QWORD PTR [rbp-0x40],rsi
   0x0000000000400650 <+15>:    mov    rax,QWORD PTR fs:0x28
   0x0000000000400659 <+24>:    mov    QWORD PTR [rbp-0x8],rax
   0x000000000040065d <+28>:    xor    eax,eax
   0x000000000040065f <+30>:    mov    QWORD PTR [rbp-0x30],0x0
   0x0000000000400667 <+38>:    mov    QWORD PTR [rbp-0x28],0x0
   0x000000000040066f <+46>:    mov    QWORD PTR [rbp-0x20],0x0
   0x0000000000400677 <+54>:    mov    DWORD PTR [rbp-0x18],0x0
   0x000000000040067e <+61>:    mov    DWORD PTR [rbp-0x1c],0xdeadbeef
   0x0000000000400685 <+68>:    mov    edi,0x400764
   0x000000000040068a <+73>:    call   0x4004d0 <puts@plt>
   0x000000000040068f <+78>:    lea    rax,[rbp-0x30]
   0x0000000000400693 <+82>:    mov    edx,0x18
   0x0000000000400698 <+87>:    mov    rsi,rax
   0x000000000040069b <+90>:    mov    edi,0x0
   0x00000000004006a0 <+95>:    call   0x400500 <read@plt>
   0x00000000004006a5 <+100>:   mov    eax,DWORD PTR [rbp-0x1c]
   0x00000000004006a8 <+103>:   cmp    eax,0xcaf3baee
   0x00000000004006ad <+108>:   jne    0x4006bb <main+122>
   0x00000000004006af <+110>:   mov    edi,0x40077c
   0x00000000004006b4 <+115>:   call   0x400626 <run_cmd>
   0x00000000004006b9 <+120>:   jmp    0x4006c5 <main+132>
   0x00000000004006bb <+122>:   mov    edi,0x400786
   0x00000000004006c0 <+127>:   call   0x400626 <run_cmd>
   0x00000000004006c5 <+132>:   mov    eax,0x0
   0x00000000004006ca <+137>:   mov    rcx,QWORD PTR [rbp-0x8]
   0x00000000004006ce <+141>:   xor    rcx,QWORD PTR fs:0x28
   0x00000000004006d7 <+150>:   je     0x4006de <main+157>
   0x00000000004006d9 <+152>:   call   0x4004e0 <__stack_chk_fail@plt>
   0x00000000004006de <+157>:   leave
   0x00000000004006df <+158>:   ret
End of assembler dump.
```

* The following displays the **main** function in _Ghidra_:

<figure><img src="../../../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

* With reference from _Ghidra_ and the disassembly of the **main** function, we know that the read function (line 20 in **main** function) corresponds to the following assembly code:

```bash
0x00000000004006a0 <+95>:    call   0x400500 <read@plt>
```

2. Set the breakpoint

* Lets set the breakpoint at the address directly after this line@`0x00000000004006a5`:

```bash
gef> break *0x00000000004006a5

gef> info b
...

gef> run
...
hello12345
...
─────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0x00007fffffffda90│+0x0000: 0x00007fffffffdbf8  →  0x00007fffffffdfb4  →  "/home/jarrettgxz/ghidra-projs/boi" ← $rsp
0x00007fffffffda98│+0x0008: 0x0000000100000000
0x00007fffffffdaa0│+0x0010: "abcde12345\n"       ← $rsi
0x00007fffffffdaa8│+0x0018: 0x00000000000a3534 ("45\n"?)
0x00007fffffffdab0│+0x0020: 0xdeadbeef00000000
0x00007fffffffdab8│+0x0028: 0x0000000000000000
0x00007fffffffdac0│+0x0030: 0x00007fffffffdbb0  →  0x0000000000400530  →  <_start+0000> xor ebp, ebp
0x00007fffffffdac8│+0x0038: 0x5c6738edf62dab00
...
```

* We can see that the value `abcde12345\n` is written from the memory address starting at `0x00007fffffffdaa0`
* Due to the size of memory represented on each line, the string value `45\n` will be present on the next address @`0x00007fffffffdaa8`     &#x20;

```bash
# view the entire C string value at address 0x00007fffffffdaa0
gef> x/s 0x00007fffffffdaa0
0x7fffffffdaa0: "abcde12345\n"

# view 10 bytes in hexadecimal representation 
gef> x/10xb 0x00007fffffffdaa0
...

# view 10 bytes in char representation
gef> x/10cb 
...

# access a random address directly
gef> x/1xb 0x00007fffffffdaa4
0x7fffffffdaa4: 0x6f
```





...

```shellscript
$ python3 - << 'EOF'
with open("boi-input.bin", "wb") as f:
    f.write(b"\xab\xcd\xe1\x23\x45")
EOF
```

```bash
gef> break *0x00000000004006a5

gef> info b
...

gef> run < boi-input.bin # input raw hex string value from the .bin file created earlier

gef> 

```







1. The actual memory byte content is low -> high memory in order of input eg. b"\xd\xc\xb\xa", 0xd will be at the lower address, while 0xa will be at the higher address&#x20;
2. 2From the same example in part 1, since each line in the GDB stack view interprets the content as little-endian integers: left -> right, MSB -> LSB - since 0xa is stored at the higher memory address (MSB), it will be displayed on the left, while 0xd displayed on the right (LSB) -> 0x0a0b0c0d - Essential steps: a. GDB reads bytes in memory (low → high) b. Interprets them as a little‑endian integer c. Prints the resulting numeric value in standard hex (MSB → LSB) - NOTE: this simply is a display convention used in GDB, but does not mean that the bytes content in memory is actually reversed
