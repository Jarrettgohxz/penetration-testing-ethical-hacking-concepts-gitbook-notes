---
description: Return-Oriented Programming (ROP)
---

# ROP

## 1. Tools

{% embed url="https://github.com/JonathanSalwan/ROPgadget" %}



## 2. How it works

In ROP, we exploit instructions from libraries with fixed addresses (eg. `libc`) with a return statement at the end (eg. `ret`). These portions of code (known as "gadgets") are chained together to accomplish a sequence of tasks. For example, loading function arguments that eventually leads to remote-code execution (RCE).

Tools such as [ROPgadget](https://github.com/JonathanSalwan/ROPgadget) can be used to simplify the process of looking for these "gadgets"

### 2.1 Example (x64)

Given a binary with the following conditions:

1. **Partial ASLR**

* Dynamic/changing stack-pointer address
* Static/constant libc library address

2. **Stack buffer overflow vulnerability**

* Overwrittes address that are eventually stored to a set of known registers which includes the return address (eg. `RIP`(x64), `ra` (MIPS), etc.)



With these conditions in mind, we are able to chain together a series of "gadgets" to eventually call the `system()` function with controlled arguments

...

1. Overwrite stack portions that corresponds to the **rdi**, **rsi**, **rdx**, etc. registers (depending on how many arguments to pass)
2. Overwrite the **RIP** register with known addresses within the **libc** library
3. The register used to store the final return address in the ROP "gadget" should be loaded with the address of the function next in the ROP
4. In conclusion, a changing **SP** value does not matter, as long as the **libc** library address is constant, and we are able to finely control the values of appropriate registers
5. ...







