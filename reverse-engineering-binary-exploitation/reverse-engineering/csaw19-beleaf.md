# CSAW'19: beleaf

{% embed url="https://github.com/guyinatuxedo/nightmare/tree/master/modules/03-beginner_re/csaw19_beleaf" %}



### Finding the address of the "main" function

...



### "main" before refinement

{% code title="main" %}
```c
undefined8 FUN_001008a1(void)

{
  size_t sVar1;
  long lVar2;
  long in_FS_OFFSET;
  ulong local_b0;
  char local_98 [136];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  printf("Enter the flag\n>>> ");
  __isoc99_scanf(&DAT_00100a78,local_98);
  sVar1 = strlen(local_98);
  if (sVar1 < 0x21) {
    puts("Incorrect!");
                    /* WARNING: Subroutine does not return */
    exit(1);
  }
  for (local_b0 = 0; local_b0 < sVar1; local_b0 = local_b0 + 1) {
    lVar2 = FUN_001007fa(local_98[local_b0]);
    if (lVar2 != *(long *)(&DAT_003014e0 + local_b0 * 8)) {
      puts("Incorrect!");
                    /* WARNING: Subroutine does not return */
      exit(1);
    }
  }
  puts("Correct!");
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return 0;
}

```
{% endcode %}

a. `local_98`: variable that stores user string input

b. `sVar1`: integer value indicating length of user input

c. `&DAT_003014e0`: value within the **.bss** (or **.data** array during runtime), which stores the series of integer values to satisfy the condition (used for checking purposes within the **FUN\_001007fa** function -more below)

* As we can see from the memory (and also since `+ local_b0 * 8` is used in the code to address), we know that the characters are in offsets of 8

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

* The first value at `0x3014e0` is **0x01** -> 1
* The second value at `0x3014e0` + 8 = `0x3014e8` is **0x9** -> 9
* The third value at `0x3014e8` + 8 = `0x3014f0` is **0x11** -> 17
* etc.

### "main" after refinement

```
...
```

### Analysis of "main" function

#### 1. First IF statement

...

#### 2. For loop

```c
  for (local_b0 = 0; local_b0 < sVar1; local_b0 = local_b0 + 1) {
    lVar2 = FUN_001007fa(local_98[local_b0]);
    if (lVar2 != *(long *)(&DAT_003014e0 + local_b0 * 8)) {
      puts("Incorrect!");
      /* WARNING: Subroutine does not return */
      exit(1);
    }
  }
```

* Simply, given an input character (each index of the input string) to the **FUN\_00107fa** function, a value stored in the `lVar2` variable will be retrieved and compared to memory address within `&DAT_003014e0`&#x20;

### "FUN\_001007fa" before refinement

```c
long FUN_001007fa(char param_1)

{
  long local_10;
  
  local_10 = 0;
  while ((local_10 != -1 && ((int)param_1 != *(int *)(&DAT_00301020 + local_10 * 4)))) {
    if ((int)param_1 < *(int *)(&DAT_00301020 + local_10 * 4)) {
      local_10 = local_10 * 2 + 1;
    }
    else if (*(int *)(&DAT_00301020 + local_10 * 4) < (int)param_1) {
      local_10 = (local_10 + 1) * 2;
    }
  }
  return local_10;
}
```

a. `&DAT_00301020`:  value within the **.bss** (or **.data** array during runtime), which stores the series of characters to form the final flag (required input string)

* As we can see from the memory (and also since `+ local_10 * 4` is used in the code to address), we know that the characters are in offsets of 4

<figure><img src="../../.gitbook/assets/image (91).png" alt=""><figcaption></figcaption></figure>

### "FUN\_001007fa" after refinement

```c
...
```

#### Main purpose of the FUN\_001007a function

Given an input value in the `param_1` variable, we need to find a value that fails the second condition in the while loop, to exit and return from the function:

```c
((int)param_1 != *(int *)(&DAT_00301020 + local_10 * 4)))
```

* Simply, we need to find a value for the `local_10` variable that will equate `param_1` to be equals to `*(int *)(&DAT_00301020 + local_10 * 4))`&#x20;
  * Notice that the final value of the `local_10` variable is returned from function when the while loop exits
  * Thus, we can ignore the logic within the while loop itself
* Notice that the return value of `local_10` will be stored in the  `lVar2` variable in the **main** function

```c
lVar2 = FUN_001007fa(local_98[local_b0]);
if (lVar2 != *(long *)(&DAT_003014e0 + local_b0 * 8)) {
      ...
```

* Thus, we can discover the values required for the `local_10` by enumerating the values from  `DAT_003014e0`&#x20;

**Enumeration steps**

**(1) local\_b0** = 0

a. **local\_bo** \* 8 = 0 \* 8 = 0

b. From **DAT\_003014e** @ offset 0-> 0x01 -> 1

c. sub value 1 into **local\_10** (_FUN\_00107fa_):

* **local\_10** \* 4 = 1 \* 4 = 4
* From **DAT\_00301020** @ offset 4-> **DAT\_00301024** -> 0x66 -> <mark style="color:$success;">**f**</mark>



**(2) local\_b0** = 1

...









