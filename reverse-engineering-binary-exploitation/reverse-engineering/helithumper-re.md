# Helithumper RE

{% embed url="https://github.com/guyinatuxedo/nightmare/blob/master/modules/03-beginner_re/helithumper_re/rev" %}

### Ghidra

#### 1. Decompiled "main"

* With basic comments

{% code overflow="wrap" %}
```c
bool main(void)
{
  char *pcVar1;
  undefined8 uVar2;
  bool bVar3;
  
  pcVar1 = (char *)calloc(0x32,1);
  puts(&DAT_00102008);
  
  __isoc99_scanf(&DAT_0010203b,pcVar1);   // __isoc99_scanf is an internal function used by the C standard library - provides underlying implementation for scanf
  
  uVar2 = validate(pcVar1); // external function called
  bVar3 = (int)uVar2 == 0;
  if (bVar3) {
    puts(&DAT_00102050);
  }
  else {
    puts("Right this way...");
  }
  return bVar3;
}
```
{% endcode %}

#### 2. Steps in cleaning up the "main" code

**2.1 Variables**

a. `char *pcVar1`&#x20;

<figure><img src="../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

1. **Line 9**: Stores the pointer returned from the `calloc` function
2. **Line 11**:  Store the input from the `__isoc99_scanf` function
3. **Line 12**: Passed as argument to the `validate()` function.

Lets rename `pcVar1` to `input_ptr` .

b. `undefined8 uVar2`&#x20;

<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

1. **Line 12**: Return value from the `validate()` function
2. **Line 13**: Compared with the value `0`&#x20;

* Since this value is compared with an integer (value 0), we can change its type to int&#x20;

Lets rename it to `check` too.

c. `bool bVar1`&#x20;

<figure><img src="../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

1. **Line 13**: Stores the value of the logical comparison
2. **Line 14**: Used in IF statement (`check` variable needs to be equals to `0`) to pass the test condition

We can simply remove this variable and merge the IF statement:

```c
if ((int)check == 0){
...
```

**2.2 Arguments**

a. **Line 10**: `puts(&DAT_00102008)`&#x20;



b. **Line 11**: `__isoc99_scanf(DAT_001203b, pcVar1)`&#x20;

The variable `&DAT_001203b` variable simply points to a memory address which stores the value `%s` .

<figure><img src="../../.gitbook/assets/image (88).png" alt=""><figcaption></figcaption></figure>



**...**





**2.3 ...**

...

<figure><img src="../../.gitbook/assets/image (84).png" alt=""><figcaption></figcaption></figure>





#### Final refined code

```c
bool main(void)
{
  char *input_ptr;
  int check;
  
  input_ptr = (char *)calloc(0x32,1);
  puts(&DAT_00102008);
  __isoc99_scanf(&DAT_0010203b,input_ptr);
  check = validate(pcVar1);
  
  if ((int)check == 0) {
    puts(&DAT_00102050);
  }
  else {
    puts("Right this way...");
  }
  return bVar3;
}
```

### GDB

```shellscript
 strings rev
/lib64/ld-linux-x86-64.so.2
libc.so.6
puts
xxxx
xxxx
Welcome to the Salty Spitoon
, How tough are ya?
Right this way...
Yeah right. Back to Weenie Hut Jr
 with ya
;*3$"
xxxx
xxxx
```

```shellscript
$ gdb rev
gdn> break main # set breakpoint on "main" function
gdb> run # run -> performs memory relotion of code addresses
gdb> disasss main # view disass
Dump of assembler code for function main:
   0x0000555555555175 <+0>:	push   %rbp
   0x0000555555555176 <+1>:	mov    %rsp,%rbp
=> 0x0000555555555179 <+4>:	sub    $0x10,%rsp
   0x000055555555517d <+8>:	mov    $0x1,%esi
   0x0000555555555182 <+13>:	mov    $0x32,%edi
   0x0000555555555187 <+18>:	call   0x555555555060 <calloc@plt>
   0x000055555555518c <+23>:	mov    %rax,-0x8(%rbp)
   0x0000555555555190 <+27>:	lea    0xe71(%rip),%rdi        # 0x555555556008
   0x0000555555555197 <+34>:	call   0x555555555030 <puts@plt>
   0x000055555555519c <+39>:	mov    -0x8(%rbp),%rax
   0x00005555555551a0 <+43>:	mov    %rax,%rsi
   0x00005555555551a3 <+46>:	lea    0xe91(%rip),%rdi        # 0x55555555603b
   0x00005555555551aa <+53>:	mov    $0x0,%eax
   0x00005555555551af <+58>:	call   0x555555555070 <__isoc99_scanf@plt>
   0x00005555555551b4 <+63>:	mov    -0x8(%rbp),%rax
   0x00005555555551b8 <+67>:	mov    %rax,%rdi
   0x00005555555551bb <+70>:	call   0x5555555551ea <validate>
   0x00005555555551c0 <+75>:	test   %eax,%eax
   0x00005555555551c2 <+77>:	je     0x5555555551d7 <main+98>
   0x00005555555551c4 <+79>:	lea    0xe73(%rip),%rdi        # 0x55555555603e
   0x00005555555551cb <+86>:	call   0x555555555030 <puts@plt>
   0x00005555555551d0 <+91>:	mov    $0x0,%eax
   0x00005555555551e8 <+115>:	leave
   0x00005555555551e9 <+116>:	ret
End of assembler dump.

gdb> break *0x0000555555555197 # first puts() function call
gdb> run # run to breakpoint
gdb> info registers rdi # view the "rdi" register content
rdi            0x555555556008      93824992239624

gdb> x/s 0x555555556008  
# view string content at address stored in rdi
# "x/s $rdi" works too
0x555555556008:	"Welcome to the Salty Spitoonâ„¢, How tough are ya?"

```



